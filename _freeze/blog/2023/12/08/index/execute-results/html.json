{
  "hash": "bbb9a6fd6eeede734da76aa17ebddd9a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Pseudobulk differential expression analysis\"\ndate: 2023-12-08\ndate-modified: last-modified\ncategories:\n    - r\n    - scrna\n    - pseudobulk\nimage: pseudobulk.png\n\nexecute: \n    eval: false\n---\n\n\n\n\nPseudobulk differential expression analysis is a method used to analyze single-cell RNA-seq data by aggregating counts at the sample level. This approach helps to reduce the noise inherent in single-cell data and provides more robust results. In this blog post, we will walk through the steps to perform pseudobulk differential expression analysis using R, including data preparation, aggregation, and differential expression testing with DESeq2.\n\n## Prepare single-cell RNA-seq data\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Load packages\nlibrary(ExperimentHub)\nlibrary(Seurat)\nlibrary(DESeq2)\nlibrary(data.table)\nlibrary(tidyverse)\nlibrary(RColorBrewer)\n\n## retrieve data\neh <- ExperimentHub()\nquery(eh, \"Kang\")\n\nsce_obj <- eh[[\"EH2259\"]]\nseu_obj <- as.Seurat(sce_obj, data = NULL)\nas_tibble(seu_obj@meta.data)\n\n## add mito percent\nseu_obj$mitoPercent <- PercentageFeatureSet(seu_obj, pattern = '^MT-')\nas_tibble(seu_obj@meta.data)\n\n## general qc and filter\nseu_obj <- subset(\n    seu_obj,\n    subset = nFeature_originalexp > 200 & nFeature_originalexp < 2500 &\n        nCount_originalexp > 800 &\n        mitoPercent < 5 &\n        multiplets == 'singlet'\n)\nmessage(ncol(sce_obj) - ncol(seu_obj), \" cells are removed ...\")\n\n## run Seurat's standard workflow steps\nseu_obj <- NormalizeData(seu_obj)\nseu_obj <- FindVariableFeatures(seu_obj)\nseu_obj <- ScaleData(seu_obj)\nseu_obj <- RunPCA(seu_obj)\nElbowPlot(seu_obj)\nseu_obj <- RunUMAP(seu_obj, dims = 1:20)\n\n## visualize\ncell_plot <- DimPlot(\n    seu_obj, reduction = \"umap\", group.by = \"cell\", label = TRUE\n)\ncond_plot <- DimPlot(seu_obj, reduction = \"umap\", group.by = \"stim\")\n\ncell_plot | cond_plot\n\n## aggregate counts to sample level with condition\n```\n:::\n\n\n\n\n## Pseudobulk workflow\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## counts aggregate to sample level\nas_tibble(seu_obj@meta.data)\nseu_obj$samples <- paste0(seu_obj$stim, seu_obj$ind)\nDefaultAssay(seu_obj)\n\ncounts <- AggregateExpression(\n    seu_obj,\n    group.by = c(\"cell\", \"samples\"),\n    assays = \"originalexp\",\n    # slot = \"counts\",\n    return.seurat = FALSE\n)\n\ncounts <- t(counts$originalexp) |> as.data.frame()\ncounts[1:5, 1:5]\n\n## get values where to split\nsplit_rows <- gsub('_.*', '', rownames(counts))\n\n## split data.frame\ncounts_list <- split.data.frame(counts, f = factor(split_rows))\ncounts_list$`B cells`[1:5, 1:5]\n\n## fix colnames and transpose\ncounts_list <- lapply(\n    counts_list, function(x) {\n        rownames(x) <- gsub('.*_(.*)', '\\\\1', rownames(x))\n        t(x)\n    }\n)\n```\n:::\n\n\n\n\n## DE testing with DESeq2\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## get counts matrix\ncounts_bcell <- counts_list[[\"B cells\"]]\n\n## generate sample level metadata\ncol_data <- data.frame(samples = colnames(counts_bcell)) |>\n    mutate(condition = if_else(\n        grepl(\"stim\", samples), \"Stimulated\", \"Control\")\n    ) |>\n    column_to_rownames(var = \"samples\")\n\n## create DESeq2 object\ndds <- DESeqDataSetFromMatrix(\n    countData = counts_bcell,\n    colData = col_data,\n    design = ~condition\n)\n\n## filter\nkeep <- rowSums(counts(dds)) >= 10\ndds <- dds[keep, ]\n\n## plot PCA\nDESeq2::plotPCA(rld, ntop = 500, intgroup = \"condition\")\nrld <- rlog(dds, blind = TRUE) ## transform counts for data visualization\n\n## hierarchical clustering\nrld_mat <- assay(rld)\nrld_cor <- cor(rld_mat)\npheatmap::pheatmap(\n    rld_cor, annotation = col_data[, c(\"condition\"), drop = FALSE]\n)\n\n## run DESeq2\ndds <- DESeq(dds)\nplotDispEsts(dds) # Plot dispersion estimates\nresultsNames(dds) # Check the coefficients for the comparison\n\n## Generate results object\nres <- results(dds, name = \"condition_Stimulated_vs_Control\", alpha = 0.05)\nres\n\n## Shrink the log2 fold changes to be more appropriate using the apeglm method\nres <- lfcShrink(\n    dds,\n    coef = \"group_id_stim_vs_ctrl\",\n    res = res,\n    type = \"apeglm\"\n)\n\n## results tibble\nres_tbl <- res |>\n    data.frame() |>\n    rownames_to_column(var = \"gene\") |>\n    as_tibble() |>\n    arrange(padj)\n\npadj_cutoff <- 0.05\nlog2fc_cutoff <- 0.58\n\n### significant genes\nsig_res <- res_tbl |>\n    dplyr::filter(padj < padj_cutoff) %>%\n    dplyr::arrange(padj)\n\nn_sig_up <- sig_res |>\n    dplyr::filter(log2FoldChange >= log2fc_cutoff) %>%\n    nrow()\nn_sig_dn <- sig_res |>\n    dplyr::filter(log2FoldChange <= -log2fc_cutoff) %>%\n    nrow()\n```\n:::\n\n\n\n\n## DE testing with Seurat\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n## Visualize the signifcant genes\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## Extract normalized counts from dds object\nnormalized_counts <- counts(dds, normalized = TRUE)\n\n## Extract top 20 DEG from resLFC (make sure to order by padj)\ntop20_sig_genes <- sig_res %>%\n    dplyr::arrange(padj) %>%\n    dplyr::pull(gene) %>%\n    head(n = 20)\n\n## Extract matching normalized count values from matrix\ntop_sig_counts <- normalized_counts[\n    rownames(normalized_counts) %in% top20_sig_genes, ]\n\n## Convert wide matrix to long data frame for ggplot2\ntop_sig_tbl <- top_sig_counts |>\n    as_tibble(rownames = \"gene\") |>\n    pivot_longer(-gene, names_to = \"samples\") |>\n    left_join(as_tibble(colData(dds), rownames = \"samples\"))\n\n## Generate scatter plot\nggplot(top_sig_tbl, aes(y = value, x = condition, color = condition)) +\n    geom_jitter(height = 0, width = 0.15) +\n    scale_y_continuous(trans = \"log10\") +\n    ylab(\"log10 of normalized expression level\") +\n    xlab(\"condition\") +\n    ggtitle(\"Top 20 Significant DE Genes\") +\n    theme(plot.title = element_text(hjust = 0.5)) +\n    facet_wrap(~gene)\n\n## Extract normalized counts for significant genes only\nsig_counts <- normalized_counts[rownames(normalized_counts) %in% sig_res$gene, ]\ndim(sig_counts)\n## Set a color-blind friendly palette\nheat_colors <- rev(brewer.pal(11, \"PuOr\"))\ncol_data$condition\nrownames(col_data)\ncolnames(sig_counts)\n## Run pheatmap using the metadata data frame for the annotation\npheatmap::pheatmap(\n    sig_counts,\n    color = heat_colors,\n    cluster_rows = TRUE,\n    show_rownames = FALSE,\n    annotation = col_data[, c(\"condition\"), drop = FALSE],\n    border_color = NA,\n    fontsize = 10,\n    scale = \"row\",\n    fontsize_row = 10,\n    height = 20\n)\n```\n:::\n\n\n\n\n## Reference\n- <https://rpubs.com/Sri_Upasna/1066070>\n- <https://hbctraining.github.io/scRNA-seq_online/lessons/pseudobulk_DESeq2_scrnaseq.html>\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}