{
  "hash": "f231ac2d31a38a5bc03fb27bcc8ad420",
  "result": {
    "markdown": "---\ntitle: \"Learning Harmony to integrate single cell RNA-seq data for batch borrection and meta analysis\"\ndate: 2023-11-26\ndate-modified: last-modified\ncategories:\n  - r\n  - scRNA-seq\nimage: harmony.jpg\n# draft: true\n# execute: \n#   freeze: true\n#   # echo: false\n#   warning: false\n#   eval: false\ndescription: Harmony allow integrating data across several variables (for example, by experimental batch and by condition),  and significant gain in speed and lower memory requirements for integration of large datasets.\n---\n\n\n\n::: {.cell layout-align=\"center\"}\n\n:::\n\n## Harmony to integrating cell line datasets from 10X\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\ndata(cell_lines)\nscaled_pcs <- cell_lines$scaled_pcs\nmeta_data <- cell_lines$meta_data\n### cells cluster by dataset initially\np1 <- do_scatter(scaled_pcs, meta_data, \"dataset\") +\n    labs(title = \"Colored by dataset\")\np2 <- do_scatter(scaled_pcs, meta_data, \"cell_type\") +\n    labs(title = \"Colored by cell type\")\n### combine plot\ncowplot::plot_grid(p1, p2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\nRun harmonoy to remove the influence of dataset-of origin from ceel embeddings. After Harmony, the datasets are now mixed and the cell types are still separate.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nharmony_embeddings <- harmony::RunHarmony(\n    scaled_pcs, meta_data, \"dataset\", verbose = FALSE\n)\np1 <- do_scatter(harmony_embeddings, meta_data, \"dataset\") +\nlabs(title = \"Colored by dataset\")\np2 <- do_scatter(harmony_embeddings, meta_data, \"cell_type\") +\n    labs(title = \"Colored by cell type\")\n### combine plot\ncowplot::plot_grid(p1, p2, nrow = 1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=100%}\n:::\n:::\n\n## MUDAN\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### get data\ndata(\"pbmcA\")\ndata(\"pbmcB\")\ndim(pbmcA)\ndim(pbmcB)\n\n### downsize the number of cells in each PBMC dataset\npbmcA <- pbmcA[, 500] # take 500 cells\npbmcB <- pbmcB[, 2000] # take 500 cells\n```\n:::\n\n\nCombine the two datasets into one cell by gene counts matrix and use a meta vector to keep track of which cell belongs to which sample\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### combine into one coutns matrix\ngenes_int <- intersect(rownames(pbmcA), rownames(pbmcB))\ncd <- cbind(pbmcA[genes_int, ], pbmcB[genes_int, ])\n\n### meta data\nmeta <- c(rep(\"pbmcA\", ncol(pbmcA)), rep(\"pbmcB\", ncol(pbmcB)))\nnames(meta) <- c(colnames(pbmcA), colnames(pbmcB))\nmeta <- factor(meta)\n\ncd[1:5, 1:2]\nmeta[1:5]\n```\n:::\n\nGiven this counts matrix, we can normalize our data, derive principal components, and perform dimensionality reduction using tSNE. However, we see prominent separation by sample due to batch effects.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### CPM normalization\nmat <- MUDAN::normalizeCounts(cd, verbose = FALSE)\n\n### variance normalize, identify overdispersed genes\nmatnorm_info <- MUDAN::normalizeVariance(mat, details = TRUE, verbose = FALSE)\n\n### log transform\nmatnorm <- log10(matnorm_info$mat + 1)\n\n### 30 PCs on over dispersed genes\npcs <- MUDAN::getPcs(\n    matnorm[matnorm_info$ods, ],\n    nGenes = length(matnorm_info$ods),\n    nPcs = 30, \n    verbose = FALSE\n)\n### TSNE embedding with regular PCS\nemb <- Rtsne::Rtsne(\n    pcs,\n    is_distance = FALSE,\n    perplexity = 30, \n    num_threads = 1,\n    verbose = FALSE\n)$Y\nrownames(emb) <- rownames(pcs)\n### plot\npar(mfrow = c(1, 1), mar = rep(2, 4))\nMUDAN::plotEmbedding(\n    emb, groups = meta, show.legend = TRUE,\n    xlab = NA, ylab = NA,\n    main = \"Regular tSNE Embedding\",\n    verbose = FALSE\n)\n```\n:::\n\nIndeed, when we inspect certain cell-type specific marker genes (MS4A1/CD20 for B-cells, CD3E for T-cells, FCGR3A/CD16 for NK cells, macrophages, and monocytes, CD14 for dendritic cells, macrophages, and monocytes), we see that cells are separating by batch rather than by their expected cell-types.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npar(mfrow = c(2, 2), mar = rep(2, 4))\ninvisible(\n    lapply(\n        c(\"MS4A1\", \"CD3E\", \"FCGR3A\", \"CD14\"),\n        function(x) {\n            gexp <- log10(mat[x, ] + 1)\n            plotEmbedding(\n                emb, col = gexp, xlab = \"NA\",\n                ylab = NA, main = x,\n                verbose = FALSE\n            )\n        }\n    )\n)\n```\n:::\n\nIf we were attempt to identify cell-types using clustering analysis at this step, we would identify a number of sample-specific clusters driven by batch effects.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nannot_bad <- getComMembership(pcs, k = 30, method = igraph::cluster_louvain)\npar(mfrow = c(1, 1), mar = rep(2, 4))\nplotEmbedding(\n    emb, groups = annot_bad, show.legend = TRUE,\n    xlab = NA, ylab = NA,\n    main = \"Jointly-indentified cell clusters\",\n    verbose = FALSE\n)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### look at cell-type proportion per sample\nt(table(annot_bad, meta))/as.numeric(table(meta))\n# Look at cell-type proportions per sample\n# print(t(table(annot_bad, meta))/as.numeric(table(meta)))\n```\n:::\n\n\n## Using Harmony with Seurat\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### load required data\ndata(\"pbmc_stim\")\n\n### generate seurat object\npbmc <- CreateSeuratObject(\n    counts = cbind(pbmc.stim, pbmc.ctrl),\n    project = \"PBMC\",\n    min.cells = 5\n) \n\n### separete conditions\npbmc@meta.data$stim <- c(\n    rep(\"STIM\", ncol(pbmc.stim)),\n    rep(\"CTRL\", ncol(pbmc.ctrl))\n)\n\n### generate a union of highly variable genes\npbmc <- pbmc |> Seurat::NormalizeData(verbose = FALSE)\n\nVariableFeatures(pbmc) <- split(row.names(pbmc@meta.data), pbmc@meta.data$stim) %>% lapply(function(cells_use) {\n    pbmc[,cells_use] %>%\n        FindVariableFeatures(selection.method = \"vst\", nfeatures = 2000) %>% \n        VariableFeatures()\n}) %>% unlist %>% unique\n## Finding variable features for layer counts\n## Finding variable features for layer counts\n\npbmc <- pbmc |> \n    ScaleData(verbose = FALSE) |> \n    RunPCA(features = VariableFeatures(pbmc), npcs = 20, verbose = FALSE)\n```\n:::\n\nClear difference between the datasets in the uncorrected PCs\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\np1 <- DimPlot(object = pbmc, reduction = \"pca\", pt.size = .1, group.by = \"stim\")\np2 <- VlnPlot(object = pbmc, features = \"PC_1\", group.by = \"stim\", pt.size = .1)\ncowplot::plot_grid(p1,p2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n### Run Harmony\nHarmony works on an existing matrix with cell embeddings and outputs its transformed version with the datasets aligned according to some user-defined experimental conditions.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### run harmony to perform integrated analysis\npbmc <- RunHarmony(pbmc, \"stim\", plot_convergence = TRUE)\n## Transposing data matrix\n## Initializing state using k-means centroids initialization\n## Harmony 1/10\n## Harmony 2/10\n## Harmony 3/10\n## Harmony 4/10\n## Harmony 5/10\n## Harmony 6/10\n## Harmony 7/10\n## Harmony 8/10\n## Harmony 9/10\n## Harmony converged after 9 iterations\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){fig-align='center' width=100%}\n:::\n\n```{.r .cell-code}\n\n### directly access the new harmony embeddings\nharmony_embeddings <- Embeddings(pbmc, \"harmony\")\nharmony_embeddings[1:5, 1:5]\n##                  harmony_1   harmony_2   harmony_3 harmony_4    harmony_5\n## ATCACTTGCTCGAA-1 -6.472885 -0.03395769 -3.37113988  4.104260  0.001600968\n## CCGGAGACTGTGAC-1 -6.901013  1.59104949 -6.36127179  4.635761 -5.605371816\n## CAAGCCCTGTTAGC-1 -6.774086 -1.21811545 -6.49162911 -9.135284 -0.197759676\n## GAGGTACTAACGGG-1 -7.435499 -0.23169621  0.07052885  2.031633 -2.190562901\n## CGCGGATGCCACAA-1 14.686943  4.38600212 -4.49637985  1.595446 -1.448223157\n\n### inspection of the modalities\np1 <- DimPlot(object = pbmc, reduction = \"harmony\", pt.size = .1, group.by = \"stim\")\np2 <- VlnPlot(object = pbmc, features = \"harmony_1\", group.by = \"stim\", pt.size = .1)\nplot_grid(p1,p2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-2.png){fig-align='center' width=100%}\n:::\n:::\n\nPlot genes correlated with the harmonized PCs\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nDimHeatmap(object = pbmc, reduction = \"harmony\", cells = 500, dims = 1:3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){fig-align='center' width=100%}\n:::\n:::\n\n### Down stream analysis\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\npbmc <- pbmc |> \n    ### perform clustering using the harmonized vectors of cells\n    FindNeighbors(reduction = \"harmony\", dims = 1:20) |> \n    FindClusters(resolution = 0.5) |> \n    identity()\n## Computing nearest neighbor graph\n## Computing SNN\n## Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck\n## \n## Number of nodes: 2000\n## Number of edges: 85805\n## \n## Running Louvain algorithm...\n## Maximum modularity in 10 random starts: 0.8883\n## Number of communities: 10\n## Elapsed time: 0 seconds\n### TSNE\npbmc <- pbmc %>%\n    RunTSNE(reduction = \"harmony\")\np1 <- DimPlot(pbmc, reduction = \"tsne\", group.by = \"stim\", pt.size = .1)\np2 <- DimPlot(pbmc, reduction = \"tsne\", label = TRUE, pt.size = .1)\nplot_grid(p1, p2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){fig-align='center' width=100%}\n:::\n:::\n\nOne important observation is to assess that the harmonized data contain biological states of the cells. Therefore by checking the following genes we can see that biological cell states are preserved after harmonization.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nFeaturePlot(object = pbmc, features= c(\"CD3D\", \"SELL\", \"CREM\", \"CD8A\", \"GNLY\", \"CD79A\", \"FCGR3A\", \"CCL2\", \"PPBP\"), \n            min.cutoff = \"q9\", cols = c(\"lightgrey\", \"blue\"), pt.size = 0.5)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){fig-align='center' width=100%}\n:::\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### UMAP\npbmc <- pbmc |> \n    RunUMAP(reduction = \"harmony\", dims = 1:20)\n## 20:34:54 UMAP embedding parameters a = 0.9922 b = 1.112\n## Found more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n## Also defined by 'spam'\n## 20:34:54 Read 2000 rows and found 20 numeric columns\n## 20:34:54 Using Annoy for neighbor search, n_neighbors = 30\n## Found more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n## Also defined by 'spam'\n## 20:34:54 Building Annoy index with metric = cosine, n_trees = 50\n## 0%   10   20   30   40   50   60   70   80   90   100%\n## [----|----|----|----|----|----|----|----|----|----|\n## **************************************************|\n## 20:34:54 Writing NN index file to temp file /var/folders/2c/9q3pg2295195bp3gnrgbzrg40000gn/T//RtmpBhrb7C/file51ff59f4665b\n## 20:34:54 Searching Annoy index using 1 thread, search_k = 3000\n## 20:34:54 Annoy recall = 100%\n## 20:34:54 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30\n## 20:34:55 Initializing from normalized Laplacian + noise (using RSpectra)\n## 20:34:55 Commencing optimization for 500 epochs, with 83254 positive edges\n## 20:34:57 Optimization finished\np1 <- DimPlot(pbmc, reduction = \"umap\", group.by = \"stim\", pt.size = .1, split.by = 'stim')\n### identify shared cell types with clustering analysis\np2 <- DimPlot(pbmc, reduction = \"umap\", label = TRUE, pt.size = .1)\nplot_grid(p1, p2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){fig-align='center' width=100%}\n:::\n:::\n\n\n\n## Reference\n- <https://portals.broadinstitute.org/harmony/index.html>\n- [Single-cell RNA-seq: Integration with Harmony](https://hbctraining.github.io/scRNA-seq_online/lessons/06a_integration_harmony.html)\n\n## Session info\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nsessionInfo()\n## R version 4.3.1 (2023-06-16)\n## Platform: aarch64-apple-darwin20 (64-bit)\n## Running under: macOS Sonoma 14.2\n## \n## Matrix products: default\n## BLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \n## LAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n## \n## locale:\n## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n## \n## time zone: Asia/Singapore\n## tzcode source: internal\n## \n## attached base packages:\n## [1] stats     graphics  grDevices utils     datasets  methods   base     \n## \n## other attached packages:\n##  [1] cowplot_1.1.1      here_1.0.1         lubridate_1.9.3    forcats_1.0.0     \n##  [5] stringr_1.5.1      dplyr_1.1.4        purrr_1.0.2        readr_2.1.4       \n##  [9] tidyr_1.3.0        tibble_3.2.1       ggplot2_3.4.4      tidyverse_2.0.0   \n## [13] Seurat_5.0.1       SeuratObject_5.0.1 sp_2.1-2           MUDAN_0.1.0       \n## [17] Matrix_1.6-3       harmony_1.1.0      Rcpp_1.0.11       \n## \n## loaded via a namespace (and not attached):\n##   [1] RcppAnnoy_0.0.21        splines_4.3.1           later_1.3.1            \n##   [4] bitops_1.0-7            polyclip_1.10-6         XML_3.99-0.15          \n##   [7] fastDummies_1.7.3       lifecycle_1.0.4         rprojroot_2.0.4        \n##  [10] edgeR_4.0.1             globals_0.16.2          lattice_0.22-5         \n##  [13] MASS_7.3-60             magrittr_2.0.3          limma_3.58.1           \n##  [16] plotly_4.10.3           rmarkdown_2.25          yaml_2.3.7             \n##  [19] httpuv_1.6.12           sctransform_0.4.1       spam_2.10-0            \n##  [22] spatstat.sparse_3.0-3   reticulate_1.34.0       pbapply_1.7-2          \n##  [25] DBI_1.1.3               RColorBrewer_1.1-3      abind_1.4-5            \n##  [28] zlibbioc_1.48.0         Rtsne_0.16              BiocGenerics_0.48.1    \n##  [31] RCurl_1.98-1.13         sva_3.50.0              GenomeInfoDbData_1.2.11\n##  [34] IRanges_2.36.0          S4Vectors_0.40.2        ggrepel_0.9.4          \n##  [37] irlba_2.3.5.1           listenv_0.9.0           spatstat.utils_3.0-4   \n##  [40] genefilter_1.84.0       goftest_1.2-3           RSpectra_0.16-1        \n##  [43] spatstat.random_3.2-2   annotate_1.80.0         fitdistrplus_1.1-11    \n##  [46] parallelly_1.36.0       leiden_0.4.3.1          codetools_0.2-19       \n##  [49] tidyselect_1.2.0        farver_2.1.1            matrixStats_1.1.0      \n##  [52] stats4_4.3.1            spatstat.explore_3.2-5  jsonlite_1.8.7         \n##  [55] ellipsis_0.3.2          progressr_0.14.0        ggridges_0.5.4         \n##  [58] survival_3.5-7          tools_4.3.1             ica_1.0-3              \n##  [61] glue_1.6.2              gridExtra_2.3           xfun_0.41              \n##  [64] mgcv_1.9-0              MatrixGenerics_1.14.0   GenomeInfoDb_1.38.0    \n##  [67] withr_2.5.2             fastmap_1.1.1           fansi_1.0.5            \n##  [70] digest_0.6.33           timechange_0.2.0        R6_2.5.1               \n##  [73] mime_0.12               colorspace_2.1-0        scattermore_1.2        \n##  [76] tensor_1.5              spatstat.data_3.0-3     RSQLite_2.3.3          \n##  [79] RhpcBLASctl_0.23-42     utf8_1.2.4              generics_0.1.3         \n##  [82] data.table_1.14.8       httr_1.4.7              htmlwidgets_1.6.3      \n##  [85] uwot_0.1.16             pkgconfig_2.0.3         gtable_0.3.4           \n##  [88] blob_1.2.4              lmtest_0.9-40           XVector_0.42.0         \n##  [91] htmltools_0.5.7         dotCall64_1.1-1         scales_1.3.0           \n##  [94] Biobase_2.62.0          png_0.1-8               knitr_1.45             \n##  [97] tzdb_0.4.0              reshape2_1.4.4          nlme_3.1-163           \n## [100] cachem_1.0.8            zoo_1.8-12              KernSmooth_2.23-22     \n## [103] vipor_0.4.5             parallel_4.3.1          miniUI_0.1.1.1         \n## [106] AnnotationDbi_1.64.1    ggrastr_1.0.2           pillar_1.9.0           \n## [109] grid_4.3.1              vctrs_0.6.5             RANN_2.6.1             \n## [112] promises_1.2.1          xtable_1.8-4            cluster_2.1.4          \n## [115] beeswarm_0.4.0          evaluate_0.23           cli_3.6.1              \n## [118] locfit_1.5-9.8          compiler_4.3.1          rlang_1.1.2            \n## [121] crayon_1.5.2            future.apply_1.11.0     labeling_0.4.3         \n## [124] ggbeeswarm_0.7.2        plyr_1.8.9              stringi_1.8.2          \n## [127] viridisLite_0.4.2       deldir_2.0-2            BiocParallel_1.36.0    \n## [130] munsell_0.5.0           Biostrings_2.70.1       lazyeval_0.2.2         \n## [133] spatstat.geom_3.2-7     RcppHNSW_0.5.0          hms_1.1.3              \n## [136] patchwork_1.1.3         bit64_4.0.5             future_1.33.0          \n## [139] KEGGREST_1.42.0         statmod_1.5.0           shiny_1.8.0            \n## [142] ROCR_1.0-11             igraph_1.5.1            memoise_2.0.1          \n## [145] bit_4.0.5\n```\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}