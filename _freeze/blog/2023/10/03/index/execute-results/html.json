{
  "hash": "fd56f009afc95d01e563933e03132954",
  "result": {
    "markdown": "---\ntitle: \"Learning scRNA-seq data analysis using Seurat package\"\ndate: 2023-09-13\ndate-modified: last-modified\ncategories:\n  - scRNA-seq\n# image: workflow.png\nimage: scRNAseq.png\ndraft: true\nexecute: \n  freeze: true\n  # echo: false\n  warning: false\n  eval: false\n---\n\n\n\n\n## Preparing reference files for scRNA-seq\n\n```bash\n### create conda env for mapping reads\nconda create --name kb\nconda activate kb\npip install kb-python\n```\n\n```bash\n### navigate to directory and active kb environment 230907_DIY_Transcriptomics/data/pbmc_1k_raw\nkb ref -d human -i Homo_sapiens.GRCh38.cdna.all.index -g t2g.txt\n```\n![](scRNAseq1.png)\n\n## Mapping reads for scRNA-seq data\n\n```bash\nkb count pbmc_1k_v3_S1_mergedLanes_R1.fastq.gz pbmc_1k_v3_S1_mergedLanes_R2.fastq.gz -i Homo_sapiens.GRCh38.cdna.all.index -x 10XV3 -g t2g.txt -t 8 --cellranger\n```\n![](scRNAseq2.png)\n\n## Imporing data into R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Load R packages\nlibrary(here)\nlibrary(tidyverse)\nlibrary(DropletUtils)\nlibrary(Seurat) # a huge, powerful, and popular library for analyzing single cell genomic data\nlibrary(Matrix)\nlibrary(scales)\nlibrary(rjson)\nlibrary(R2HTML)\nlibrary(DT)\nlibrary(scater) # quality control and visualization for scRNA-seq data\nlibrary(scran) # for low level processing of scRNA-seq data\nlibrary(tensorflow)\nlibrary(cellassign) \nlibrary(SingleR) # automated cell type annotation ('label transfer') using reference data\nlibrary(celldex) # a large collection of reference expression datasets with curated cell type labels for use with SingleR package\nlibrary(pheatmap)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Load raw matix\nraw_mtx <- readMM(here(\n    \"data\", \"230907_DIY_Transcriptomics\", \"pbmc_1k_v3_scRNAseq_processed\",\n    \"counts_unfiltered\", \"cellranger\", \"matrix.mtx\"\n))\nhead(raw_mtx)\n### load genes\ngenes <- read.csv(here(\n    \"data\", \"230907_DIY_Transcriptomics\", \"pbmc_1k_v3_scRNAseq_processed\",\n    \"counts_unfiltered\", \"cellranger\", \"genes.tsv\"\n    ), sep = \"\\t\", header = FALSE\n)\nhead(genes)\n# add ensemble gene_ids to the data matrix as rownames\nrownames(raw_mtx) <- genes[,1] \n### add cell barcodes as column names\ncolnames(raw_mtx) <- read.csv(here(\n    \"data\", \"230907_DIY_Transcriptomics\", \"pbmc_1k_v3_scRNAseq_processed\",\n    \"counts_unfiltered\", \"cellranger\", \"barcodes.tsv\"\n    ), sep = \"\\t\", header = FALSE\n)[, 1]\n```\n:::\n\n## Step5: Quality \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# use DropletUtils package to get probability that each barcode is a cell\nout <- emptyDrops(raw_mtx) \n\n# set threshold probability for calling a cell\nkeep <- out$FDR <= 0.05 \n\n# use threshold to remove empty drops\nkeep[is.na(keep)] <- FALSE\nfilt_mtx <- raw_mtx[,keep] \n\n# write out filtered results\nwrite10xCounts(\n    here(\"data\", \"230907_DIY_Transcriptomics\", \"pbmc_1k_v3_scRNAseq_processed\",\"counts_filtered\"), \n    gene.symbol = genes[,2], \n    filt_mtx, overwrite=TRUE) \n```\n:::\n\n## Basic Quality assessment \n\n\n::: {.cell}\n\n```{.r .cell-code}\n### R script that contains the bc_rank_plot and print_HTML functions we'll use to produce a QC report\nsource(\n    here(\"data\", \"230907_DIY_Transcriptomics\", \"functions.R\")\n)\n\n### load filtered mtx\nfilt_mtx <- readMM(\n    here(\"data\", \"230907_DIY_Transcriptomics\", \"pbmc_1k_v3_scRNAseq_processed\"\n    , \"counts_filtered\", \"matrix.mtx\")\n)\n\n### load run info from JSON files produced by Kb\nkb_stats <- c(\n    fromJSON(file = here(\n        \"data\", \"230907_DIY_Transcriptomics\", \"pbmc_1k_v3_scRNAseq_processed\", \n        \"inspect.json\")), \n    fromJSON(file = here(\n        \"data\", \"230907_DIY_Transcriptomics\", \"pbmc_1k_v3_scRNAseq_processed\", \n        \"run_info.json\"))\n)\n# determine chemistry version\ntech <- grep(\"10X(.*)\", strsplit(kb_stats$call, \"\\\\s\")[[1]], value=T) \n\n# make a nice/simple table that summarizes that stats\nseq_stats <- data.frame(\n    stat = c(\n        \"Sequencing technology\", \"Number of reads processed\", \"% reads pseudoaligned\", # get sequencing/alignment stats \n        \"% reads on whitelist\"), \n    value = prettyNum(\n        c(tech, kb_stats$n_processed, kb_stats$p_pseudoaligned, \n        round(kb_stats$percentageReadsOnWhitelist,2)), big.mark = \",\")\n)\n\n# calculate cell stats and save to df\np_cnts_in_cells <- round((sum(filt_mtx)/sum(raw_mtx))*100, 2) \nmed_cnts_cell <- median(colSums(filt_mtx))\nmed_genes_cell <- median(apply(filt_mtx, 2, function(x) sum(x >= 1)))\ntot_genes_detected <- sum(rowSums(filt_mtx)>=1)\ncell_stats <- data.frame(\n    stat = c(\n        \"Estimated number of cells\", \"% counts in cells\", \n        \"Median counts per cell\", \"Median genes per cell\", \"Total genes detected\"\n    ), \n    value = prettyNum(\n        c(ncol(filt_mtx), p_cnts_in_cells, med_cnts_cell,\n        med_genes_cell, tot_genes_detected), big.mark = \",\"\n    )\n)\n\n# get rank stats\nstats <- barcodeRanks(raw_mtx)\n\n# load raw cells\nraw_cells <- read.csv(\n    here(\"data\", \"230907_DIY_Transcriptomics\", \"pbmc_1k_v3_scRNAseq_processed\",\n    \"counts_unfiltered\", \"cellranger\", \"barcodes.tsv\"), header = FALSE, sep =\"\\t\"\n    )[,1] \n\n# load filtered cells\nfilt_cells <- read.csv(\n    here(\"data\", \"230907_DIY_Transcriptomics\", \"pbmc_1k_v3_scRNAseq_processed\",\n    \"counts_filtered\", \"barcodes.tsv\"), header = FALSE, sep =\"\\t\"\n    )[,1] \n\n# create barcode rank plot png\nbc_rank_plot(\n    stats = stats, \n    raw_cells = raw_cells, \n    filt_cells = filt_cells, \n    save = here(\n        \"data\", \"230907_DIY_Transcriptomics\", \"pbmc_1k_v3_scRNAseq_processed\", \n        \"counts_filtered\", \"barcode_rank.png\"\n    ) \n)\n\n# output a HTML summary of the run\nprint_HTML(\n    seq_stats = seq_stats, \n    cell_stats = cell_stats, \n    dir = here(\n        \"data\", \"230907_DIY_Transcriptomics\", \"pbmc_1k_v3_scRNAseq_processed\", \n        \"counts_filtered\"\n    ), \n    sample_id = NULL\n)\n```\n:::\n\n\n### create Seurat object\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndatadir <- here(\n        \"data\", \"230907_DIY_Transcriptomics\", \"pbmc_1k_v3_scRNAseq_processed\", \n        \"counts_filtered\"\n    )\nlist.files(datadir)\n\nexpression_matrix <- Read10X(\n  datadir,\n  gene.column = 2,\n  cell.column = 1,\n  unique.features = TRUE,\n  strip.suffix = FALSE\n)\n### create seurat object\npbmc_1k_seurat <- CreateSeuratObject(\n    counts = expression_matrix, min.cells = 3\n    )  %>% \n  NormalizeData(verbose = FALSE) %>% \n  FindVariableFeatures(verbose = FALSE)\n```\n:::\n\n### Calculate the percentage of mitochondrial reads\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# NOTE: change 'MT' to 'mt' for mouse\npbmc_1k_seurat[[\"percent.mt\"]] <- PercentageFeatureSet(\n    object = pbmc_1k_seurat, pattern = \"^MT-\"\n    ) \n# Make violin plot\nVlnPlot(\n    pbmc_1k_seurat, \n    c(\"nCount_RNA\", \"nFeature_RNA\", \"percent.mt\"), \n    pt.size = 0.1\n)\n\n# filter data\npbmc_1k_seurat <- subset(pbmc_1k_seurat, subset = \n                           nCount_RNA < 20000 & \n                           nCount_RNA > 1000 & \n                           nFeature_RNA > 1000 & \n                           percent.mt < 20)\n# NOTE: you need to be careful when setting cut-offs that you're not losing unique cell populations\n\n# another QA plot\nggplot(pbmc_1k_seurat@meta.data, aes(nCount_RNA, nFeature_RNA)) +\n  geom_point(alpha = 0.7, size = 0.5) +\n  labs(x = \"Total UMI counts per cell\", y = \"Number of genes detected\")\n# Potential things to look for in the type of QA plot produced above:\n# 1. Data points in the bottom LEFT hand quadrant = low genes and UMIs per cell. May represent poor quality cells.\n# 2. Data points in the bottom RIGHT hand quadrant = low genes but high UMIs per cell. These could be dying cells, but also could represent a population of a low complexity celltype (i.e red blood cells).\n```\n:::\n\n\n## Cluster identification\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Plot UMAP ----\n# it is standard practice to apply a linear transformation ('scaling') before PCA. For single cell data this includes:\n# 1. Shifting the expression of each gene, so that the mean expression across cells is 0\n# 2. Scaling the expression of each gene, so that the variance across cells is 1\n# This gives equal weight in downstream analyses, so that highly-expressed genes do not dominate\npbmc_1k_seurat <- ScaleData(pbmc_1k_seurat, verbose = FALSE)\npbmc_1k_seurat <- RunPCA(pbmc_1k_seurat, npcs = 40, verbose = FALSE)\npbmc_1k_seurat <- RunUMAP(pbmc_1k_seurat, reduction = \"pca\", dims = 1:40)\npbmc_1k_seurat <- FindNeighbors(pbmc_1k_seurat, reduction = \"pca\", dims = 1:40)\npbmc_1k_seurat <- FindClusters(pbmc_1k_seurat, resolution = 0.5)\nDimPlot(pbmc_1k_seurat, reduction = \"umap\", split.by = \"orig.ident\", label = TRUE)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Find cluster-specific genes ----\n# generally speaking there are three main ways you can find cluster-specific marker genes with Seurat\n# 1. 'FindMarkers' to compare a select cluster to all other cells not in that cluster\n# 2. 'FindAllMarkers' to compare EACH cluster to all other cells\n# 3. 'FindConservedMarkers' to identify genes conserved (shared) between two defined clusters\n\n# We'll start with FindMarkers, since it allows you to choose exactly which cluster you'd like to focus on.\ncluster1.markers <- FindMarkers(pbmc_1k_seurat, ident.1 = 1, min.pct = 0.25)\ncluster1.markers$pct.diff <- cluster1.markers$pct.1 - cluster1.markers$pct.2\ncluster1.markers.df <- as_tibble(cluster1.markers, rownames = \"geneID\")\n# Export DEGs for each cluster (ranked by avg_logFC > 0.5)\nmyTopHits_cluster1 <- cluster1.markers.df %>% arrange(desc(avg_log2FC))\nmyTopHits_cluster1 <- dplyr::slice(myTopHits_cluster1, 1:20)\n\n# you can make this list of genes into an interactive table\ndatatable(myTopHits_cluster1, \n          extensions = c('KeyTable', \"FixedHeader\"), \n          caption = 'Table 1: Cluster 1 genes',\n          options = list(keys = TRUE, searchHighlight = TRUE, pageLength = 10, lengthMenu = c(\"10\", \"25\", \"50\", \"100\"))) %>%\n  formatRound(columns=c(2:11), digits=2)\n\n# plot genes of interest on UMAP\nFeaturePlot(pbmc_1k_seurat, \n            reduction = \"umap\", \n            features = c(\"IGHM\"),\n            pt.size = 0.4, \n            order = TRUE,\n            #split.by = \"orig.ident\",\n            min.cutoff = 'q10',\n            label = FALSE)\n\n# now let's try with FindAllMarkers\npbmc.1k.markers <- FindAllMarkers(pbmc_1k_seurat, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)\n\n# let's take the top 10 marker genes for each cluster and plot as a heatmap\ntop10 <- pbmc.1k.markers %>% \n  group_by(cluster) %>%\n  top_n(n = 10, wt = avg_log2FC)\nDoHeatmap(pbmc_1k_seurat, features = top10$gene)\n```\n:::\n\n\n## Assign identity to cell clusters\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n## Integration of multiple samples\n\n## Reference\n\n- [DIY Transcriptomics](https://diytranscriptomics.com/)\n- [In-depth-NGS-Data-Analysis-Course](https://hbctraining.github.io/In-depth-NGS-Data-Analysis-Course/sessionIV/lessons/SC_pre-QC.html)\n\n## SessionInfo\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}