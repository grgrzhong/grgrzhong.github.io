{
  "hash": "0a9d4892eb5c88d4965b53b54ade30c6",
  "result": {
    "markdown": "---\ntitle: \"Single-cell RNA-seq data analysis using Seurat package\"\ndate: 2023-10-22\ndate-modified: last-modified\ncategories:\n  - scRNA-seq\n# image: workflow.png\nimage: scRNAseq.png\ndraft: true\nexecute: \n  freeze: true\n  # echo: false\n  warning: false\n  eval: false\n---\n\n\n\n\nThis tutorial is credited from [here.](https://github.com/quadbio/scRNAseq_analysis_vignette)\n\n# Part 1\n\n## Step 0: Load packages\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Seurat)\nlibrary(patchwork)\n```\n:::\n\n# Step 1: Create s Seurat object\n\nSeurat object allow us to store all the steps and results along the whole analysis.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### read in the matrix and rename its row names and colnames by gene symbols and cell barcodes, repectively.\ncounts <- Read10X(data.dir = \"learn/scRNAseq_analysis_vignette/data/DS1/\")\nseurat <- CreateSeuratObject(counts, project = \"DS1\")\n```\n:::\n\n\nAlternatively, do this manually\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(Matrix)\ncounts <- readMM(\"learn/scRNAseq_analysis_vignette/data/DS1/matrix.mtx.gz\")\nbarcodes <- read.table(\n    \"learn/scRNAseq_analysis_vignette/data/DS1/barcodes.tsv.gz\", \n    stringsAsFactors = FALSE\n    )[, 1]\nfeatures <- read.csv(\n    \"learn/scRNAseq_analysis_vignette/data/DS1/features.tsv.gz\", \n    stringsAsFactors = FALSE, sep = \"\\t\", header = FALSE\n    )\nrownames(counts) <- make.unique(features[, 2])\ncolnames(counts) <- barcodes\nseurat <- CreateSeuratObject(counts, project = \"DS1\")\n```\n:::\n\n\n# Step 2: Quality Control\n\nThe most common quality control is to filter out:\n\n- Cells with too few genes detected\n- cells with too many genes detected\n- Cells with high mitochondrial transcript percentage\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### calculate mitochondial transcript percentages\nseurat[[\"percent.mt\"]] <- PercentageFeatureSet(seurat, pattern = \"^MT[-\\\\.]\")\n### look at the distribution\nVlnPlot(\n    seurat, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"), ncol = 3\n    )\n### don't show individual cells\nVlnPlot(\n    seurat, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"), ncol = 3,\n    pt.size = 0\n    )\n```\n:::\n\nWe expect number of detected genes and number of detected transcripts are well correlated across cells while mitochondrial transcript percentage is not.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- FeatureScatter(\n    seurat, feature1 = \"nCount_RNA\", feature2 = \"percent.mt\"\n    )\np2 <- FeatureScatter(\n    seurat, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\"\n    )\np1 + p2\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### set a reasonable cutoff\nseurat <- subset(\n    seurat, \n    subset = nFeature_RNA > 500 & nFeature_RNA < 5000 & percent.mt < 5\n)\n```\n:::\n\n\n# Step 3: Normalization\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat <- NormalizeData(seurat)\n```\n:::\n\n# Step 4: Feature selection\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat <- FindVariableFeatures(seurat, nfeatures = 3000)\n\n### visualize the result\ntop_features <- head(VariableFeatures(seurat), 20)\np1 <- VariableFeaturePlot(seurat)\np2 <- LabelPoints(\n    plot = p1, points = top_features, repel = TRUE\n)\np1 + p2\n```\n:::\n\n# Step 5: Data scaling\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat <- ScaleData(seurat)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### remove unwanted source of variation\nseurat <- ScaleData(\n    seurat, vars.to.regress = c(\"nFeature_RNA\", \"percent.mt\")\n    )\n```\n:::\n\n# Step 6: Linear dimensionality reduction using PCA\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat <- RunPCA(seurat, npcs = 50)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nElbowPlot(seurat, ndims = ncol(Embeddings(seurat, \"pca\")))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nPCHeatmap(seurat, dims = 1:20, cells = 500, balanced = TRUE, ncol = 4)\n```\n:::\n\n# Step 7: Non-linear dimension reduction for visualization\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat <- RunTSNE(seurat, dims = 1:20)\nseurat <- RunUMAP(seurat, dims = 1:20)\n\np1 <- TSNEPlot(seurat)\np2 <- UMAPPlot(seurat)\n\np1 + p2\n```\n:::\n\n\nCheck whether certain cell types or cell states exist in the data\n\n- MKI67: a marker of G2M phase of cell cycle\n- DCX: a pan-(immature) neuro marker\n- FOXG1: a telencephalon marker\n- DLX2: a ventral telencephalon marker\n- EMX1: a dorssal telencephalon (cortex) marker\n- OTX2: a midbrain and diencephalon neuron marker\n- LHX9: a diencephalon and midbrain neuron marker\n- TFAP2A: a midbrain-hindbrain boundary marker\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- FeaturePlot(\n    seurat, \n    c(\"MKI67\", \"NES\", \"DCX\", \"FOXG1\", \"DLX2\", \"EMX1\", \"OTX2\", \"LHX9\", \"TFAP2A\"),\n    ncol = 3, reduction = \"tsne\"\n)\np2 <- FeaturePlot(\n    seurat, \n    c(\"MKI67\", \"NES\", \"DCX\", \"FOXG1\", \"DLX2\", \"EMX1\", \"OTX2\", \"LHX9\", \"TFAP2A\"),\n    ncol = 3, reduction = \"umap\"\n)\n\np1 / p2\n```\n:::\n\n\n# Step 8: Cluster the cells\n\n# Step 9: Annotate cell clusters\n# Step 10: Pseudotemporal cell ordering\n# Step 11: Save the result\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}