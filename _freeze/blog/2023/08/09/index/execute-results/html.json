{
  "hash": "f8dba1238bf4b3bea8ff00b95541e067",
  "result": {
    "markdown": "---\ntitle: \"Combat to remove batch effects in high-throughput experiments\"\ndate: 2023-08-09\ndate-modified: last-modified\ncategories:\n  - batch effect\nimage: index.png\ndescription: Comat models batch effects as multiplicative and additive noise to the biological signal and uses a Bayesian framework to fit linear models that factor such noise out of the readouts.\n---\n\n\n\n## What is batch effect?\n\nBatch effects are sub-groubs of measurements that have qualitatively different behaviour\nacross conditions and unrelated to the biological or scientific variables in a study.\n - Experiments run on different time\n - Different technician\n - Differnt doing the sample preparation\n - Sequencing at a differnt institute\n - Prepare the sample at different timepoint\n - Different lots of reagents, chips or instruments ...\n\nAll of these factors are considered to be factors as batches\n\n## Why is batch effect a problem\n\n- Not biological difference\n- Just the other factors are taking actions, and are showing differences\n- Most of the time, batch effect deviate our finding from the real biological relevant information\n\nTry our best to eliminate batch effect to get a real difference between conditions! \n\n## SVA package for removing batch effects\n\nThe assumption is that you will be trying to analyze the association between the variables of\ninterest and gene expression, adjusting for the adjustment variables\n\n## Setting up the data from an ExpressionSet\n\n- The data should be a matrix with features in the rows and samples in the columns.\n- The data should be standardized before applying for correction.\n\n![](sample.png)\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### Load packages\nlibrary(here)\nlibrary(tidyverse)\nlibrary(sva)\nlibrary(bladderbatch)\nlibrary(pamr)\nlibrary(limma)\nlibrary(survival)\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### load data\ndata(bladderdata)\n### variable data\npheno <- pData(bladderEset)\nclass(pheno)\n## [1] \"data.frame\"\nhead(pheno, n = 5)\n##              sample outcome batch cancer\n## GSM71019.CEL      1  Normal     3 Normal\n## GSM71020.CEL      2  Normal     2 Normal\n## GSM71021.CEL      3  Normal     2 Normal\n## GSM71022.CEL      4  Normal     3 Normal\n## GSM71023.CEL      5  Normal     3 Normal\n### expression data matrix\nedata <- exprs(bladderEset)\nclass(edata)\n## [1] \"matrix\" \"array\"\nhead(edata[, 1:5])\n##           GSM71019.CEL GSM71020.CEL GSM71021.CEL GSM71022.CEL GSM71023.CEL\n## 1007_s_at    10.115170     8.628044     8.779235     9.248569    10.256841\n## 1053_at       5.345168     5.063598     5.113116     5.179410     5.181383\n## 117_at        6.348024     6.663625     6.465892     6.116422     5.980457\n## 121_at        8.901739     9.439977     9.540738     9.254368     8.798086\n## 1255_g_at     3.967672     4.466027     4.144885     4.189338     4.078509\n## 1294_at       7.775183     7.110154     7.248430     7.017220     7.896419\n### create full model matrix, including both the adjustment variables and the variable of interest (cancer status)\nmod <- model.matrix(~ as.factor(cancer), data = pheno)\n### Create null model matrix, ontains only the adjustment variables.\nmod0 <- model.matrix(~ 1, data = pheno) \n```\n:::\n\n## Eestimate batch effect and other artifacts using sva\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### identify the number of latent factors that need to be estimated\nn_sv <- num.sv(edata, mod, method = \"leek\")\nn_sv\n## [1] 2\n## estimate the surrogate variables\nsvaobj <- sva(edata, mod, mod0, n.sv = n_sv)\n## Number of significant surrogate variables is:  2 \n## Iteration (out of 5 ):1  2  3  4  5\nstr(svaobj)\n## List of 4\n##  $ sv       : num [1:57, 1:2] -0.02717 -0.00618 0.07737 -0.00114 -0.02062 ...\n##  $ pprob.gam: num [1:22283] 0.999 0.977 1 1 1 ...\n##  $ pprob.b  : num [1:22283] 0.9956 0.9998 0.0702 0.9998 1 ...\n##  $ n.sv     : num 2\nsummary(lm(svaobj$sv ~ pheno$batch))\n## Response Y1 :\n## \n## Call:\n## lm(formula = Y1 ~ pheno$batch)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -0.26953 -0.11076  0.00787  0.10399  0.19069 \n## \n## Coefficients:\n##              Estimate Std. Error t value Pr(>|t|)\n## (Intercept) -0.018470   0.038694  -0.477    0.635\n## pheno$batch  0.006051   0.011253   0.538    0.593\n## \n## Residual standard error: 0.1345 on 55 degrees of freedom\n## Multiple R-squared:  0.00523,\tAdjusted R-squared:  -0.01286 \n## F-statistic: 0.2891 on 1 and 55 DF,  p-value: 0.5929\n## \n## \n## Response Y2 :\n## \n## Call:\n## lm(formula = Y2 ~ pheno$batch)\n## \n## Residuals:\n##      Min       1Q   Median       3Q      Max \n## -0.23973 -0.07467 -0.02157  0.08116  0.25629 \n## \n## Coefficients:\n##              Estimate Std. Error t value Pr(>|t|)    \n## (Intercept)  0.121112   0.034157   3.546 0.000808 ***\n## pheno$batch -0.039675   0.009933  -3.994 0.000194 ***\n## ---\n## Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n## \n## Residual standard error: 0.1187 on 55 degrees of freedom\n## Multiple R-squared:  0.2248,\tAdjusted R-squared:  0.2107 \n## F-statistic: 15.95 on 1 and 55 DF,  p-value: 0.0001945\nboxplot(svaobj$sv[, 2] ~ pheno$batch)\npoints(svaobj$sv[, 2] ~ jitter(as.numeric(pheno$batch)), col = as.numeric(pheno$batch))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\ndev.off()\n## null device \n##           1\n```\n:::\n\n## Adjusting for surrogate variables using f.pvalue function\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### calculate the parametric F-test p-values for each row of a data matrix\npvalues <- f.pvalue(edata, mod, mod0)\n### adjust them for multiple teseting\nqvalues <- p.adjust(pvalues, method = \"BH\")\n```\n:::\n\nNearly 70% of the genes are strongly differentially expressed at an FDR of less than 5% between groups.\\\nThis number seems artifically high.\n\nGet the adjusted p-values and q-values accounting for surrogate variables.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### include the surrogate variables\nmodsv <- cbind(mod, svaobj$sv)\nmod0sv <- cbind(mod0, svaobj$sv)\npvalues_sv <- f.pvalue(edata, modsv, mod0sv)\nqvalues_sv <- p.adjust(pvalues, method = \"BH\")\n```\n:::\n\n## Adjusting for surrogate variables using the limma\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### fit the linear model with the surrogate variabels\nfit <- lmFit(edata, modsv)\n### compute the contrasts between cancer/normal terms\ncontrast_matrix <- cbind(\n  \"C1\" = c(-1, 1, 0, rep(0, svaobj$n.sv)),\n  \"C2\" = c(0, -1, 1, rep(0, svaobj$n.sv))\n)\nfit_contrasts <- contrasts.fit(fit, contrast_matrix)\n\n### calculate the test statistics\neb <- eBayes(fit_contrasts)\ntopTableF(eb, adjust = \"BH\")\n## topTableF is obsolete and will be removed in a future version of limma. Please considering using topTable instead.\n##                    C1          C2   AveExpr        F      P.Value    adj.P.Val\n## 207783_x_at -13.45607  0.26592268 12.938786 8622.529 1.207531e-69 1.419929e-65\n## 201492_s_at -13.27594  0.15357702 13.336090 8605.649 1.274450e-69 1.419929e-65\n## 208834_x_at -12.76411  0.06134018 13.160201 6939.501 4.749368e-67 3.527673e-63\n## 212869_x_at -13.77957  0.26008165 13.452076 6593.346 1.939773e-66 1.080599e-62\n## 212284_x_at -13.59977  0.29135767 13.070844 5495.716 2.893287e-64 1.289423e-60\n## 208825_x_at -12.70979  0.08250821 13.108072 5414.741 4.350100e-64 1.615555e-60\n## 211445_x_at -10.15890 -0.06633356  9.853817 5256.114 9.845076e-64 3.133969e-60\n## 213084_x_at -12.59345  0.03015520 13.046529 4790.107 1.260201e-62 3.510132e-59\n## 201429_s_at -13.33686  0.28358293 12.941208 4464.995 8.675221e-62 2.147888e-58\n## 214327_x_at -12.60146  0.20934783 11.832607 4312.087 2.257025e-61 5.029329e-58\n```\n:::\n\n\n\n## Adjusting for known batches using Combat \n\n`ComBat` returns a “cleaned” data matrix after batch effects have been removed. Here we pass a model matrix with any known adjustment variables and a second parameter that is the batch variable.\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### get known batch variable\nbatch <- pheno$batch\n### model matrix\nmodcombat <- model.matrix(~1, data = pheno)\nmodcancer <- model.matrix(~cancer, data = pheno)\n\n### Using parametric empirical Bayesian adjustments.\ncombat_edata <- ComBat(\n    dat = edata,\n    batch = batch, \n    mod = modcombat,\n    par.prior = TRUE, # performs parametric empirical Bayesian adjustment\n    # par.prior = FALSE, # performs non-parametric empirical Bayesian adjustment\n    prior.plots = FALSE,\n    mean.only = FALSE, # only adjust the mean of the batch effects across batches\n    ref.batch = NULL\n)\n\n### significance analysis\npvalue_combat <- f.pvalue(combat_edata, mod, mod0)\nqvalue_combat <- p.adjust(pvalue_combat, method = \"BH\")\n\ncombat_fit <- lm.fit(modcancer, t(combat_edata))\nhist(combat_fit$coefficients[2, ], col = 4, breaks = 100)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n## Removing known batch effects with a linear model\n\nIn this case, we use two models. \n- One with the variable we care about - cancer status\n- the other is just the known adjustment variables, in this case, we assume none\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nmod_batch <- model.matrix(~as.factor(cancer) + as.factor(batch), data = pheno)\nmod0_batch <- model.matrix(~as.factor(batch), data = pheno)\npvalues_batch <- f.pvalue(edata, mod_batch, mod0_batch)\nqvalues_batch <- p.adjust(pvalues_batch, method = \"BH\")\n\nfit <- lm.fit(mod_batch, t(edata))\nhist(fit$coefficients[2, ], col = 4, breaks = 100)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n\n## Comparing ComBat and linear adjustment\n\nWe can compare the estimated coefficients from Combat and linear adjustment by looking at the right coefficients for each model.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nplot(\n  fit$coefficients[2, ], combat_fit$coefficients[2, ], col = 4,\n  xlab = \"Linear Model\", ylab = \"Combat\", xlim = c(-5, 5), ylim = c(-5, 5)\n)\nabline(c(0, 1), col = 2, lwd = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\ndev.off()\n## null device \n##           1\n```\n:::\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### Add the surrogate variables to the model matrix and perform model fit\nmodsv <- cbind(mod, svaobj$sv)\nfitsv <- lm.fit(modsv, t(edata))\n\n### Compare the fit from surrogate variable analysis to the other two\npar(mfrow = c(1, 2))\nplot(\n  fitsv$coefficients[2,], combat_fit$coefficients[2, ], \n  col = 2, xlab = \"SVA\", ylab = \"Combat\", xlim = c(-5, 5), ylim = c(-5, 5)\n)\nabline(c(0, 1), col = 1, lwd = 3)\nplot(\n  fitsv$coefficients[2,], fit$coefficients[2, ], \n  col = 2, xlab = \"SVA\", ylab = \"Linear model\", xlim = c(-5, 5), ylim = c(-5, 5)\n)\nabline(c(0, 1), col = 1, lwd = 3)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){fig-align='center' width=672}\n:::\n\n```{.r .cell-code}\ndev.off()\n## null device \n##           1\n```\n:::\n\n## Combat-seq for batch adjustment on RNA-seq count data\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### expression matrix\ncount_matrix <- matrix(\n  rnbinom(400, size = 10, prob =  0.1),\n  nrow = 50, ncol = 8\n)\n### batch\nbatch <- c(rep(1, 4), rep(2, 4))\n\n### adjust\nadjusted <- ComBat_seq(\n  count_matrix, \n  batch = batch, \n  group = NULL\n)\n## Found 2 batches\n## Using null model in ComBat-seq.\n## Adjusting for 0 covariate(s) or covariate level(s)\n## Estimating dispersions\n## Fitting the GLM model\n## Shrinkage off - using GLM estimates for parameters\n## Adjusting the data\n\n### specify one biological variable\ngroup <- rep(c(0, 1), 4)\nadjusted_counts <- ComBat_seq(\n  count_matrix, \n  batch = batch, \n  group = group\n)\n## Found 2 batches\n## Using full model in ComBat-seq.\n## Adjusting for 1 covariate(s) or covariate level(s)\n## Estimating dispersions\n## Fitting the GLM model\n## Shrinkage off - using GLM estimates for parameters\n## Adjusting the data\n\n### multiple biological variabels\ncov1 <- rep(c(0, 1), 4)\ncov2 <- c(0, 0, 1, 1, 0, 0, 1, 1)\ncovar_mat <- cbind(cov1, cov2)\nadjusted_counts <- ComBat_seq(\n  count_matrix, \n  batch = batch, \n  group = NULL, \n  covar_mod = covar_mat\n)\n## Found 2 batches\n## Using null model in ComBat-seq.\n## Adjusting for 2 covariate(s) or covariate level(s)\n## Estimating dispersions\n## Fitting the GLM model\n## Shrinkage off - using GLM estimates for parameters\n## Adjusting the data\n```\n:::\n\n\n## Variance filtering to speed computations\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nn_sv <- num.sv(edata, mod, vfilter = 2000, method = \"leek\")\nsvaobj <- sva(edata, mod, mod0, n.sv = n_sv, vfilter = 2000)\n## Number of significant surrogate variables is:  46 \n## Iteration (out of 5 ):1  2  3  4  5\n```\n:::\n\n## Applying the fsva function to remove batch effects for prediction\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### seprate data to traning and test set\nset.seed(12354)\ntrain_indicator <- sample(1:57, size = 30, replace = FALSE)\ntest_indicator <- (1:57)[-train_indicator]\ntrain_data <- edata[, train_indicator]\ntest_data <- edata[, test_indicator]\ntrain_pheno <- pheno[train_indicator, ]\ntest_pheno <- pheno[test_indicator, ]\n\n### pamr package can be used to train a predictive model and test that prediction\nmydata <- list(x = train_data, y = train_pheno$cancer)\nmytrain <- pamr.train(mydata)\n## 123456789101112131415161718192021222324252627282930\ntable(\n  pamr.predict(mytrain, test_data, threshold = 2),\n  test_pheno$cancer\n)\n##         \n##          Biopsy Cancer Normal\n##   Biopsy      4      0      0\n##   Cancer      0     15      0\n##   Normal      1      4      3\n\n### calculate surrogate variables for training set\ntrain_mod <- model.matrix(~cancer, data = train_pheno)\ntrain_mod0 <- model.matrix(~1, data = train_pheno)\ntrain_sv <- sva(train_data, train_mod, train_mod0)\n## Number of significant surrogate variables is:  5 \n## Iteration (out of 5 ):1  2  3  4  5\n\n### adjust both the training data and the test data\nfsvaobj <- fsva(train_data, train_mod, train_sv, test_data)\nmydata_sv <- list(x = fsvaobj$db, y = train_pheno$cancer)\nmytrain_sv <- pamr.train(mydata_sv)\n## 123456789101112131415161718192021222324252627282930\n```\n:::\n\n\n## Reference\n\n- [Batch effects and confounders](http://jtleek.com/genstats/inst/doc/02_13_batch-effects.html)\n- [The SVA package for removing batch effects and other unwanted variation in high-throughput experiments](https://www.bioconductor.org/packages/release/bioc/vignettes/sva/inst/doc/sva.pdf)\n- [Managing batch effects](https://evayiwenwang.github.io/Managing_batch_effects/)\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}