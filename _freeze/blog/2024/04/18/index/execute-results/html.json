{
  "hash": "8f803a37fdd2d584f46a732d8527db02",
  "result": {
    "markdown": "---\ntitle: \"Multiplex image-based phenotypic data analysis\"\ndate: 2024-04-18\ndate-modified: last-modified\ncategories:\n  - mIF\n\nimage: image-profile.jpg\n# description: All the learning materials are from credited or adapted from Harvard Chan Bioinformatics Core. \nexecute: \n  freeze: auto\n  eval: true\n---\n\n\n\n## Initial general setup\n\n::: {.cell}\n\n```{.r .cell-code}\n### Required libraries\n# if (!require(\"BiocManager\", quietly = TRUE))\n#     install.packages(\"BiocManager\")\n# BiocManager::install(\n#     c(\n#         \"rmarkdown\", \"bookdown\", \"pheatmap\", \"viridis\", \"zoo\",\n#         \"devtools\", \"testthat\", \"tiff\", \"distill\", \"ggrepel\",\n#         \"patchwork\", \"mclust\", \"RColorBrewer\", \"uwot\", \"Rtsne\",\n#         \"harmony\", \"Seurat\", \"SeuratObject\", \"cowplot\", \"kohonen\",\n#         \"caret\", \"randomForest\", \"ggridges\", \"cowplot\",\n#         \"gridGraphics\", \"scales\", \"tiff\", \"harmony\", \"Matrix\",\n#         \"CATALYST\", \"scuttle\", \"scater\", \"dittoSeq\",\n#         \"tidyverse\", \"BiocStyle\", \"batchelor\", \"bluster\", \"scran\",\n#         \"lisaClust\", \"spicyR\", \"iSEE\", \"imcRtools\", \"cytomapper\",\n#         \"imcdatasets\", \"cytoviewer\"\n#     ),\n#     force = TRUE\n# )\n\nlibrary(here)\nlibrary(fs)\nlibrary(qs)\nlibrary(tidyverse)\nlibrary(ggrepel)\nlibrary(ggridges)\nlibrary(patchwork)\nlibrary(cowplot)\nlibrary(RColorBrewer)\nlibrary(viridis)\nlibrary(imcRtools)\nlibrary(cytomapper)\nlibrary(dittoSeq)\nlibrary(CATALYST)\nlibrary(pheatmap)\nlibrary(BiocParallel)\nlibrary(tiff)\nlibrary(EBImage)\nlibrary(mclust)\nlibrary(batchelor)\nlibrary(scater)\nlibrary(viridis)\nlibrary(harmony)\nlibrary(BiocSingular)\nlibrary(Seurat)\nlibrary(SeuratObject)\nlibrary(Rphenograph)\nlibrary(igraph)\nlibrary(bluster)\nlibrary(scran)\nlibrary(caret)\nlibrary(lisaClust)\nlibrary(scuttle)\nlibrary(ComplexHeatmap)\nlibrary(circlize)\n\n### Project directory\ndir <- here(\"projects/2024_IMC_Profile\")\nset.seed(20240419)\n```\n:::\n\n\n## Data preparation\n\nIMC example data is from [here](https://zenodo.org/records/7624451)\n\n### Download example data\n\n::: {.cell}\n\n```{.r .cell-code}\n### Create directory for data \nfs::dir_create(dir, \"data/steinbock\")\n\n### Download sample/patient metadata information\ndownload.file(\n    \"https://zenodo.org/record/7575859/files/sample_metadata.csv\",\n    destfile = here(dir, \"data/sample_metadata.csv\")\n)\n\n### Download intensities\nurl <- \"https://zenodo.org/record/7624451/files/intensities.zip\"\ndestfile <- here(dir, \"data/steinbock/intensities.zip\")\ndownload.file(url, destfile)\nunzip(destfile, exdir = here(dir, \"data/steinbock\"), overwrite = TRUE)\nunlink(destfile)\n\n### Download regionprops\nurl <- \"https://zenodo.org/record/7624451/files/regionprops.zip\"\ndestfile <- here(dir, \"data/steinbock/regionprops.zip\")\ndownload.file(url, destfile)\nunzip(destfile, exdir = here(dir, \"data/steinbock\"), overwrite = TRUE)\nunlink(destfile)\n\n### Download neighbors\nurl <- \"https://zenodo.org/record/7624451/files/neighbors.zip\"\ndestfile <- here(dir, \"data/steinbock/neighbors.zip\")\ndownload.file(url, destfile)\nunzip(destfile, exdir = here(dir, \"data/steinbock\"), overwrite = TRUE)\nunlink(destfile)\n\n### Download images\nurl <- \"https://zenodo.org/record/7624451/files/img.zip\"\ndestfile <- here(dir, \"data/steinbock/img.zip\")\ndownload.file(url, destfile)\nunzip(destfile, exdir = here(dir, \"data/steinbock\"), overwrite = TRUE)\nunlink(destfile)\n\n### Download masks\nurl <- \"https://zenodo.org/record/7624451/files/masks_deepcell.zip\"\ndestfile <- here(dir, \"data/steinbock/masks_deepcell.zip\")\ndownload.file(url, destfile)\nunzip(destfile, exdir = here(dir, \"data/steinbock\"), overwrite = TRUE)\nunlink(destfile)\n\n### Download individual files\ndownload.file(\n    \"https://zenodo.org/record/7624451/files/panel.csv\",\n    here(dir, \"data/steinbock/panel.csv\")\n)\ndownload.file(\n    \"https://zenodo.org/record/7624451/files/images.csv\",\n    here(dir, \"data/steinbock/images.csv\")\n)\ndownload.file(\n    \"https://zenodo.org/record/7624451/files/steinbock.sh\",\n    here(dir, \"data/steinbock/steinbock.sh\")\n)\n\n### Files for spillover matrix estimation\ndownload.file(\n    \"https://zenodo.org/record/7575859/files/compensation.zip\",\n    here(dir, \"data/compensation.zip\")\n)\nunzip(\n    here(dir, \"data/compensation.zip\"),\n    exdir = here(dir, \"data\"), overwrite = TRUE\n)\nunlink(here(dir, \"data/compensation.zip\"))\n\n### Gated cells\ndownload.file(\n    \"https://zenodo.org/record/8095133/files/gated_cells.zip\",\n    here(dir, \"data/gated_cells.zip\")\n)\nunzip(\n    here(dir, \"data/gated_cells.zip\"),\n    exdir = here(dir, \"data\"), overwrite = TRUE\n)\nunlink(here(dir, \"data/gated_cells.zip\"))\n```\n:::\n\n\n### Preprocess data\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Read steinbock generated data into a SpatialExperiment object\nspe <- imcRtools::read_steinbock(here(dir, \"data/steinbock/\"))\nspe\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: SpatialExperiment \ndim: 40 47859 \nmetadata(0):\nassays(1): counts\nrownames(40): MPO HistoneH3 ... DNA1 DNA2\nrowData names(12): channel name ... Final.Concentration...Dilution\n  uL.to.add\ncolnames: NULL\ncolData names(8): sample_id ObjectNumber ... width_px height_px\nreducedDimNames(0):\nmainExpName: NULL\naltExpNames(0):\nspatialCoords names(2) : Pos_X Pos_Y\nimgData names(1): sample_id\n```\n:::\n\n```{.r .cell-code}\n### Summarized pixel intensities\ncounts(spe)[1:5, 1:5]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               [,1]       [,2]      [,3]      [,4]      [,5]\nMPO       0.5751064  0.4166667 0.4975494  0.890154 0.1818182\nHistoneH3 3.1273082 11.3597883 2.3841440  7.712961 1.4512715\nSMA       0.2600939  1.6720383 0.1535190  1.193948 0.2986703\nCD16      2.0347747  2.5880536 2.2943074 15.629083 0.6084220\nCD38      0.2530137  0.6826669 1.1902979  2.126060 0.2917793\n```\n:::\n\n```{.r .cell-code}\n### Metadata\nhead(colData(spe))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 6 rows and 8 columns\n     sample_id ObjectNumber      area axis_major_length axis_minor_length\n   <character>    <numeric> <numeric>         <numeric>         <numeric>\n1 Patient1_001            1        12           7.40623           1.89529\n2 Patient1_001            2        24          16.48004           1.96284\n3 Patient1_001            3        17           9.85085           1.98582\n4 Patient1_001            4        24           8.08290           3.91578\n5 Patient1_001            5        22           8.79367           3.11653\n6 Patient1_001            6        25           9.17436           3.46929\n  eccentricity  width_px height_px\n     <numeric> <numeric> <numeric>\n1     0.966702       600       600\n2     0.992882       600       600\n3     0.979470       600       600\n4     0.874818       600       600\n5     0.935091       600       600\n6     0.925744       600       600\n```\n:::\n\n```{.r .cell-code}\n### SpatialExperiment container stores locations of all cells in the\n### spatialCoords slot\nhead(spatialCoords(spe))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Pos_X     Pos_Y\n[1,] 468.5833 0.4166667\n[2,] 515.8333 0.4166667\n[3,] 587.2353 0.4705882\n[4,] 192.2500 1.2500000\n[5,] 231.7727 0.9090909\n[6,] 270.1600 1.0400000\n```\n:::\n\n```{.r .cell-code}\ncolPair(spe, \"neighborhood\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSelfHits object with 257116 hits and 0 metadata columns:\n                from        to\n           <integer> <integer>\n       [1]         1        27\n       [2]         1        55\n       [3]         2        10\n       [4]         2        44\n       [5]         2        81\n       ...       ...       ...\n  [257112]     47858     47836\n  [257113]     47859     47792\n  [257114]     47859     47819\n  [257115]     47859     47828\n  [257116]     47859     47854\n  -------\n  nnode: 47859\n```\n:::\n\n```{.r .cell-code}\nhead(rowData(spe))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 6 rows and 12 columns\n              channel        name      keep   ilastik  deepcell  cellpose\n          <character> <character> <numeric> <numeric> <numeric> <logical>\nMPO               Y89         MPO         1        NA        NA        NA\nHistoneH3       In113   HistoneH3         1         1         1        NA\nSMA             In115         SMA         1        NA        NA        NA\nCD16            Pr141        CD16         1        NA        NA        NA\nCD38            Nd142        CD38         1        NA        NA        NA\nHLADR           Nd143       HLADR         1        NA        NA        NA\n          Tube.Number              Target Antibody.Clone Stock.Concentration\n            <numeric>         <character>    <character>           <numeric>\nMPO              2101 Myeloperoxidase MPO Polyclonal MPO                 500\nHistoneH3        2113          Histone H3           D1H2                 500\nSMA              1914                 SMA            1A4                 500\nCD16             2079                CD16       EPR16784                 500\nCD38             2095                CD38        EPR4106                 500\nHLADR            2087              HLA-DR        TAL 1B5                 500\n          Final.Concentration...Dilution   uL.to.add\n                             <character> <character>\nMPO                              4 ug/mL         0.8\nHistoneH3                        1 ug/mL         0.2\nSMA                           0.25 ug/mL        0.05\nCD16                             5 ug/mL           1\nCD38                           2.5 ug/mL         0.5\nHLADR                            1 ug/mL         0.2\n```\n:::\n\n```{.r .cell-code}\n### Add additional metadata: generate unique identifiers per cell\ncolnames(spe) <- paste0(spe$sample_id, \"_\", spe$ObjectNumber)\n\n### Read patient metadata\nmeta <- read_csv(here(dir, \"data/sample_metadata.csv\"), show_col_types = FALSE)\n\n### Extract patient id and ROI id from sample name\nspe$patient_id <- str_extract(spe$sample_id, \"Patient[1-4]\")\nspe$ROI <- str_extract(spe$sample_id, \"00[1-8]\")\n\n### Store cancer type in SPE object\nspe$indication <- meta$Indication[match(spe$patient_id, meta$`Sample ID`)]\nunique(spe$patient_id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Patient1\" \"Patient2\" \"Patient3\" \"Patient4\"\n```\n:::\n\n```{.r .cell-code}\nunique(spe$ROI)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"001\" \"002\" \"003\" \"004\" \"005\" \"006\" \"007\" \"008\"\n```\n:::\n\n```{.r .cell-code}\nunique(spe$indication)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"SCCHN\" \"BCC\"   \"NSCLC\" \"CRC\"  \n```\n:::\n\n```{.r .cell-code}\n### Transform counts\np1 <- dittoRidgePlot(\n    spe, var = \"CD3\", group.by = \"patient_id\", assay = \"counts\"\n) +\n    ggtitle(\"CD3 - before transformation\")\n\n### Perform counts transformation using an inverse hyperbolic sine function\nassay(spe, \"exprs\") <- asinh(counts(spe) / 1)\n\np2 <- dittoRidgePlot(\n    spe, var = \"CD3\", group.by = \"patient_id\", assay = \"exprs\"\n) +\n    ggtitle(\"CD3 - after transformation\")\n\nwrap_plots(p1, p2, ncol = 2) +\n    plot_layout(guides = \"collect\") & theme(legend.position = \"bottom\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.22\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0984\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Add Feature meta for easy specifies the markers of interest.\nrowData(spe)$use_channel <- !grepl(\"DNA|Histone\", rownames(spe))\n\n### Define color schemes for different metadata entries of the data\ncolor_vectors <- list()\n\nROI <- setNames(\n    brewer.pal(length(unique(spe$ROI)), name = \"BrBG\"),\n    unique(spe$ROI)\n)\n\npatient_id <- setNames(\n    brewer.pal(length(unique(spe$patient_id)), name = \"Set1\"),\n    unique(spe$patient_id)\n)\n\nsample_id <- setNames(\n    c(\n        brewer.pal(6, \"YlOrRd\")[3:5],\n        brewer.pal(6, \"PuBu\")[3:6],\n        brewer.pal(6, \"YlGn\")[3:5],\n        brewer.pal(6, \"BuPu\")[3:6]\n    ),\n    unique(spe$sample_id)\n)\n\nindication <- setNames(\n    brewer.pal(length(unique(spe$indication)), name = \"Set2\"),\n    unique(spe$indication)\n)\n\ncolor_vectors$ROI <- ROI\ncolor_vectors$patient_id <- patient_id\ncolor_vectors$sample_id <- sample_id\ncolor_vectors$indication <- indication\n\nmetadata(spe)$color_vectors <- color_vectors\n```\n:::\n\n\n### Read in images\n\n::: {.cell}\n\n```{.r .cell-code}\nimages <- loadImages(here(dir, \"data/steinbock/img/\"))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nAll files in the provided location will be read in.\n```\n:::\n\n```{.r .cell-code}\nmasks <- loadImages(here(dir, \"data/steinbock/masks_deepcell/\"), as.is = TRUE)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nAll files in the provided location will be read in.\n```\n:::\n\n```{.r .cell-code}\n### Make sure that the channel order is identical between the single-cell data and the images\nchannelNames(images) <- rownames(spe)\nimages\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCytoImageList containing 14 image(s)\nnames(14): Patient1_001 Patient1_002 Patient1_003 Patient2_001 Patient2_002 Patient2_003 Patient2_004 Patient3_001 Patient3_002 Patient3_003 Patient4_005 Patient4_006 Patient4_007 Patient4_008 \nEach image contains 40 channel(s)\nchannelNames(40): MPO HistoneH3 SMA CD16 CD38 HLADR CD27 CD15 CD45RA CD163 B2M CD20 CD68 Ido1 CD3 LAG3 / LAG33 CD11c PD1 PDGFRb CD7 GrzB PDL1 TCF7 CD45RO FOXP3 ICOS CD8a CarbonicAnhydrase CD33 Ki67 VISTA CD40 CD4 CD14 Ecad CD303 CD206 cleavedPARP DNA1 DNA2 \n```\n:::\n\n```{.r .cell-code}\n### Order of the images\nall.equal(names(images), names(masks))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] TRUE\n```\n:::\n\n```{.r .cell-code}\n### Extract patient id from image name\npatient_id <- str_extract(names(images), \"Patient[1-4]\")\n\n### Retrieve cancer type per patient from metadata file\nindication <- meta$Indication[match(patient_id, meta$`Sample ID`)]\n\n### Store patient and image level information in elementMetadata\nmcols(images) <- mcols(masks) <- DataFrame(\n    sample_id = names(images),\n    patient_id = patient_id,\n    indication = indication\n)\n```\n:::\n\n\n### Save data\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqsave(spe, here(dir, \"data/spe.qs\"))\nqsave(images, here(dir, \"data/images.qs\"))\nqsave(masks, here(dir, \"data/masks.qs\"))\n```\n:::\n\n\n## Spillover correction\n\n### Generate the spillover matrix\n\n::: {.cell}\n\n```{.r .cell-code}\n### Create SingleCellExperiment from TXT files\nsce <- readSCEfromTXT(here(dir, \"data/compensation/\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSpotted channels:  Y89, In113, In115, Pr141, Nd142, Nd143, Nd144, Nd145, Nd146, Sm147, Nd148, Sm149, Nd150, Eu151, Sm152, Eu153, Sm154, Gd155, Gd156, Gd158, Tb159, Gd160, Dy161, Dy162, Dy163, Dy164, Ho165, Er166, Er167, Er168, Tm169, Er170, Yb171, Yb172, Yb173, Yb174, Lu175, Yb176\nAcquired channels:  Ar80, Y89, In113, In115, Xe131, Xe134, Ba136, La138, Pr141, Nd142, Nd143, Nd144, Nd145, Nd146, Sm147, Nd148, Sm149, Nd150, Eu151, Sm152, Eu153, Sm154, Gd155, Gd156, Gd158, Tb159, Gd160, Dy161, Dy162, Dy163, Dy164, Ho165, Er166, Er167, Er168, Tm169, Er170, Yb171, Yb172, Yb173, Yb174, Lu175, Yb176, Ir191, Ir193, Pt196, Pb206\nChannels spotted but not acquired:  \nChannels acquired but not spotted:  Ar80, Xe131, Xe134, Ba136, La138, Ir191, Ir193, Pt196, Pb206\n```\n:::\n\n```{.r .cell-code}\nassay(sce, \"exprs\") <- asinh(counts(sce)/5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Quality control\n### Log10 median pixel counts per spot and channel\nplotSpotHeatmap(sce)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### Thresholded on 200 pixel counts\nplotSpotHeatmap(sce, log = FALSE, threshold = 200)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Optional pixel binning\n### Define grouping\nbin_size = 10\nsce2 <- binAcrossPixels(sce, bin_size = bin_size)\n\n### Log10 median pixel counts per spot and channel\nplotSpotHeatmap(sce2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### Thresholded on 200 pixel counts\nplotSpotHeatmap(sce2, log = FALSE, threshold = 200)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-2.png){width=672}\n:::\n\n```{.r .cell-code}\n### Filtering incorrectly assigned pixels\nbc_key <- as.numeric(unique(sce$sample_mass))\nbc_key <- bc_key[order(bc_key)]\nsce <- assignPrelim(sce, bc_key = bc_key)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nDebarcoding data...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n o ordering\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n o classifying events\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nNormalizing...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nComputing deltas...\n```\n:::\n\n```{.r .cell-code}\nsce <- estCutoffs(sce)\nsce <- applyCutoffs(sce)\n\n### Visualize the correctly and incorrectly assigned pixels\ncur_table <- table(sce$bc_id, sce$sample_mass)\npheatmap(\n    log10(cur_table + 1),\n    cluster_rows = FALSE,\n    cluster_cols = FALSE\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-3.png){width=672}\n:::\n\n```{.r .cell-code}\n### Compute the fraction of unassigned pixels per spot\ncur_table[\"0\", ] / colSums(cur_table)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   113    115    141    142    143    144    145    146    147    148    149 \n0.1985 0.1060 0.2575 0.3195 0.3190 0.3825 0.3545 0.4280 0.3570 0.4770 0.4200 \n   150    151    152    153    154    155    156    158    159    160    161 \n0.4120 0.4025 0.4050 0.4630 0.4190 0.4610 0.3525 0.4020 0.4655 0.4250 0.5595 \n   162    163    164    165    166    167    168    169    170    171    172 \n0.4340 0.4230 0.4390 0.4055 0.5210 0.3900 0.3285 0.3680 0.5015 0.4900 0.5650 \n   173    174    175    176     89 \n0.3125 0.4605 0.4710 0.2845 0.3015 \n```\n:::\n\n```{.r .cell-code}\nsce <- filterPixels(sce, minevents = 40, correct_pixels = TRUE)\n\n### Compute spillover matrix\nsce <- computeSpillmat(sce)\nisotope_list <- CATALYST::isotope_list\nisotope_list$Ar <- 80\nplotSpillmat(sce, isotope_list = isotope_list)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: The `guide` argument in `scale_*()` cannot be `FALSE`. This was deprecated in\nggplot2 3.3.4.\nℹ Please use \"none\" instead.\nℹ The deprecated feature was likely used in the CATALYST package.\n  Please report the issue at <https://github.com/HelenaLC/CATALYST/issues>.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-4.png){width=672}\n:::\n\n```{.r .cell-code}\n### Save spillover matrix in variable\nsm <- metadata(sce)$spillover_matrix\nwrite.csv(sm, here(dir, \"data/sm.csv\"))\n```\n:::\n\n\n### Single-cell data compensation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspe <- qread(here(dir, \"data/spe.qs\"))\n\nrowData(spe)$channel_name <- paste0(rowData(spe)$channel, \"Di\")\nspe <- compCytof(\n    spe, sm,\n    transform = TRUE, cofactor = 1,\n    isotope_list = isotope_list,\n    overwrite = FALSE\n)\n\n### Check the effect of channel spillover compensation\nbefore <- dittoScatterPlot(\n    spe, x.var = \"Ecad\", y.var = \"CD303\",\n    assay.x = \"exprs\", assay.y = \"exprs\"\n) +\n    ggtitle(\"Before compensation\")\n\nafter <- dittoScatterPlot(\n    spe, x.var = \"Ecad\", y.var = \"CD303\",\n    assay.x = \"compexprs\", assay.y = \"compexprs\"\n) +\n    ggtitle(\"After compensation\")\n\nwrap_plots(before, after)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n\n```{.r .cell-code}\nassay(spe, \"counts\") <- assay(spe, \"compcounts\") \nassay(spe, \"exprs\") <- assay(spe, \"compexprs\") \nassay(spe, \"compcounts\") <- assay(spe, \"compexprs\") <- NULL\n```\n:::\n\n\n### Image compensation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nimages <- qread(here(dir, \"data/images.qs\"))\n\nchannelNames(images) <- rowData(spe)$channel_name\n\nadapted_sm <- adaptSpillmat(\n    sm, channelNames(images),\n    isotope_list = isotope_list\n)\n\nimages_comp <- compImage(\n    images, adapted_sm,\n    BPPARAM = MulticoreParam()\n)\n\n### Visualize the image before and after compensation\n# Before compensation\nplotPixels(\n    images[5], colour_by = \"Yb173Di\",\n    image_title = list(text = \"Yb173 (Ecad) - before\", position = \"topleft\"),\n    legend = NULL, bcg = list(Yb173Di = c(0, 4, 1))\n)\nplotPixels(\n    images[5], colour_by = \"Yb174Di\",\n    image_title = list(text = \"Yb174 (CD303) - before\", position = \"topleft\"),\n    legend = NULL, bcg = list(Yb174Di = c(0, 4, 1))\n)\n\n# After compensation\nplotPixels(\n    images_comp[5], colour_by = \"Yb173Di\",\n    image_title = list(text = \"Yb173 (Ecad) - after\", position = \"topleft\"),\n    legend = NULL, bcg = list(Yb173Di = c(0, 4, 1))\n)\nplotPixels(\n    images_comp[5], colour_by = \"Yb174Di\",\n    image_title = list(text = \"Yb174 (CD303) - after\", position = \"topleft\"),\n    legend = NULL, bcg = list(Yb174Di = c(0, 4, 1))\n)\n\n### Re-set the channelNames to their biological targtes\nchannelNames(images_comp) <- rownames(spe)\n```\n:::\n\n### Write out compensated images\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfs::dir_create(here(dir, \"data/comp_img\"))\nlapply(\n    names(images_comp), function(x) {\n        writeImage(as.array(images_comp[[x]]) / (2^16 - 1),\n            paste0(dir, \"/data/comp_img/\", x, \".tiff\"),\n            bits.per.sample = 16)\n    }\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Save the compensated SpatialExperiment and CytoImageList objects\nqsave(spe, here(dir, \"data/spe.qs\"))\nqsave(images_comp, here(dir,\"data/images.qs\"))\n```\n:::\n\n\n## Image and cell quality control\n\n### Segmentation quality control\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Load data: 63.01 MB\nimages <- qread(here(dir, \"data/images.qs\"))\nmasks <- qread(here(dir, \"data/masks.qs\"))\nspe <- qread(here(dir, \"data/spe.qs\"))\nlobstr::obj_size(spe, image, masks)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Select 3 random images\nset.seed(20220118)\nimg_ids <- sample(seq_along(images), 3)\n\n### Image- and channel-wise min-max normalization and scaled to a range of 0-1\ncur_images <- images[img_ids]\ncur_images <- cytomapper::normalize(cur_images, separateImages = TRUE)\n\n### Clipping the maximum intensity to 0.2\ncur_images <- cytomapper::normalize(cur_images, inputRange = c(0, 0.2))\n\n### Segmentation approach here appears to correctly segment cells\ncytomapper::plotPixels(\n    cur_images,\n    mask = masks[img_ids],\n    img_id = \"sample_id\",\n    missing_colour = \"white\",\n    colour_by = c(\"CD163\", \"CD20\", \"CD3\", \"Ecad\", \"DNA1\"),\n    colour = list(\n        CD163 = c(\"black\", \"yellow\"),\n        CD20 = c(\"black\", \"red\"),\n        CD3 = c(\"black\", \"green\"),\n        Ecad = c(\"black\", \"cyan\"),\n        DNA1 = c(\"black\", \"blue\")\n    ),\n    image_title = NULL,\n    legend = list(\n        colour_by.title.cex = 0.7,\n        colour_by.labels.cex = 0.7\n    )\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### Heatmap to observe cell segmentation quality and\n### potentially also antibody specificity issues\n\n### Sub-sample the dataset to 2000 cells\ncur_cells <- sample(seq_len(ncol(spe)), 2000)\n\n### Epithelial cells (Ecad+) and immune cells (CD45RO+) can be differentiate\n### Some of the markers are detected in specific cells (e.g., Ki67, CD20, Ecad) ### while others are more broadly expressed across cells (e.g., HLADR, B2M, CD4).\ndittoHeatmap(\n    spe[, cur_cells],\n    genes = rownames(spe)[rowData(spe)$use_channel],\n    assay = \"exprs\",\n    cluster_cols = TRUE,\n    scale = \"none\",\n    heatmap.colors = viridis(100),\n    annot.by = \"indication\",\n    annotation_colors = list(\n        indication = metadata(spe)$color_vectors$indication\n    )\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n:::\n\n\n### Image_level quality control\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Average SNR versus the average signal intensity across all images\ncur_snr <- lapply(names(images), function(x){\n    img <- images[[x]]\n    mat <- apply(img, 3, function(ch){\n        # Otsu threshold\n        thres <- otsu(ch, range = c(min(ch), max(ch)), levels = 65536)\n        # Signal-to-noise ratio\n        snr <- mean(ch[ch > thres]) / mean(ch[ch <= thres])\n        # Signal intensity\n        ps <- mean(ch[ch > thres])\n        \n        return(c(snr = snr, ps = ps))\n    })\n    t(mat) |>  as.data.frame() |>  \n        mutate(image = x,\n               marker = colnames(mat)) |>  \n        pivot_longer(cols = c(snr, ps))\n})\n\ncur_snr <- do.call(rbind, cur_snr)\n\ncur_snr |>  \n    group_by(marker, name) |> \n    summarize(log_mean = log2(mean(value))) |> \n    pivot_wider(names_from = name, values_from = log_mean) |> \n    ggplot() +\n    geom_point(aes(ps, snr)) +\n    geom_label_repel(aes(ps, snr, label = marker)) +\n    theme_minimal(base_size = 15) + ylab(\"Signal-to-noise ratio [log2]\") +\n    xlab(\"Signal intensity [log2]\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'marker'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: ggrepel: 9 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### Remove markers that have a positive signal of below 2 per image\ncur_snr <- cur_snr |>  \n    pivot_wider(names_from = name, values_from = value) |> \n    filter(ps > 2) |> \n    pivot_longer(cols = c(snr, ps))\n\ncur_snr |>  \n    group_by(marker, name) |> \n    summarize(log_mean = log2(mean(value))) |> \n    pivot_wider(names_from = name, values_from = log_mean) |> \n    ggplot() +\n    geom_point(aes(ps, snr)) +\n    geom_label_repel(aes(ps, snr, label = marker)) +\n    theme_minimal(base_size = 15) + ylab(\"Signal-to-noise ratio [log2]\") +\n    xlab(\"Signal intensity [log2]\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`summarise()` has grouped output by 'marker'. You can override using the\n`.groups` argument.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: ggrepel: 7 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-2.png){width=672}\n:::\n\n```{.r .cell-code}\n### Compute the percentage of covered image area\ncell_density <- colData(spe) |> \n    as.data.frame() |> \n    group_by(sample_id) |> \n    # Compute the number of pixels covered by cells and \n    # the total number of pixels\n    summarize(cell_area = sum(area),\n              no_pixels = mean(width_px) * mean(height_px)) |> \n    # Divide the total number of pixels \n    # by the number of pixels covered by cells\n    mutate(covered_area = cell_area / no_pixels)\n\n### Visualize the image area covered by cells per image\nggplot(cell_density) +\n        geom_point(aes(reorder(sample_id,covered_area), covered_area)) + \n        theme_minimal(base_size = 15) +\n        theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 15)) +\n        ylim(c(0, 1)) +\n        ylab(\"% covered area\") + xlab(\"\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-3.png){width=672}\n:::\n\n```{.r .cell-code}\n### Normalize and clip images\ncur_images <- images[c(\"Patient4_005\", \"Patient4_007\")]\ncur_images <- cytomapper::normalize(cur_images, separateImages = TRUE)\ncur_images <- cytomapper::normalize(cur_images, inputRange = c(0, 0.2))\n\nplotPixels(cur_images,\n           mask = masks[c(\"Patient4_005\", \"Patient4_007\")],\n           img_id = \"sample_id\",\n           missing_colour = \"white\",\n           colour_by = c(\"CD163\", \"CD20\", \"CD3\", \"Ecad\", \"DNA1\"),\n           colour = list(CD163 = c(\"black\", \"yellow\"),\n                         CD20 = c(\"black\", \"red\"),\n                         CD3 = c(\"black\", \"green\"),\n                         Ecad = c(\"black\", \"cyan\"),\n                         DNA1 = c(\"black\", \"blue\")),\n           legend = list(colour_by.title.cex = 0.7,\n                         colour_by.labels.cex = 0.7))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-4.png){width=672}\n:::\n\n```{.r .cell-code}\n###  Visualize the mean marker expression per image to identify images with outlying marker expression\nimage_mean <- scuttle::aggregateAcrossCells(\n    spe, \n    ids = spe$sample_id, \n    statistics=\"mean\",\n    use.assay.type = \"counts\"\n)\n\nassay(image_mean, \"exprs\") <- asinh(counts(image_mean))\n\ndittoHeatmap(\n    image_mean, \n    genes = rownames(spe)[rowData(spe)$use_channel],\n    assay = \"exprs\", cluster_cols = TRUE, scale = \"none\",\n    heatmap.colors = viridis(100), \n    annot.by = c(\"indication\", \"patient_id\", \"ROI\"),\n    annotation_colors = list(\n        indication = metadata(spe)$color_vectors$indication,\n                                      patient_id = metadata(spe)$color_vectors$patient_id,\n                                      ROI = metadata(spe)$color_vectors$ROI\n        ),\n    show_colnames = TRUE\n)                        \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-16-5.png){width=672}\n:::\n:::\n\n\n### Cell_level quality control\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(220224)\nmat <- sapply(seq_len(nrow(spe)), function(x){\n    cur_exprs <- assay(spe, \"exprs\")[x,]\n    cur_counts <- assay(spe, \"counts\")[x,]\n    \n    cur_model <- Mclust(cur_exprs, G = 2)\n    mean1 <- mean(cur_counts[cur_model$classification == 1])\n    mean2 <- mean(cur_counts[cur_model$classification == 2])\n    \n    signal <- ifelse(mean1 > mean2, mean1, mean2)\n    noise <- ifelse(mean1 > mean2, mean2, mean1)\n    \n    return(c(snr = signal/noise, ps = signal))\n})\n    \ncur_snr <- t(mat) |>  as.data.frame() |>  \n        mutate(marker = rownames(spe))\n\ncur_snr |>  ggplot() +\n    geom_point(aes(log2(ps), log2(snr))) +\n    geom_label_repel(aes(log2(ps), log2(snr), label = marker)) +\n    theme_minimal(base_size = 15) + ylab(\"Signal-to-noise ratio [log2]\") +\n    xlab(\"Signal intensity [log2]\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: ggrepel: 2 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### Observe the distributions of cell size across the individual images\ndittoPlot(spe, var = \"area\", \n          group.by = \"sample_id\", \n          plots = \"boxplot\") +\n        ylab(\"Cell area\") + xlab(\"\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-2.png){width=672}\n:::\n\n```{.r .cell-code}\nsummary(spe$area)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Min. 1st Qu.  Median    Mean 3rd Qu.    Max. \n   5.00   47.00   70.00   76.48   98.00  466.00 \n```\n:::\n\n```{.r .cell-code}\nsum(spe$area < 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0\n```\n:::\n\n```{.r .cell-code}\nspe <- spe[,spe$area >= 5]\n\n### Absolute measure of cell density\ncell_density <- colData(spe) |> \n    as.data.frame() |> \n    group_by(sample_id) |> \n    summarize(cell_count = n(),\n           no_pixels = mean(width_px) * mean(height_px)) |> \n    mutate(cells_per_mm2 = cell_count/(no_pixels/1000000))\n\nggplot(cell_density) +\n    geom_point(aes(reorder(sample_id,cells_per_mm2), cells_per_mm2)) + \n    theme_minimal(base_size = 15) + \n    theme(axis.text.x = element_text(angle = 90, hjust = 1, size = 8)) +\n    ylab(\"Cells per mm2\") + xlab(\"\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-3.png){width=672}\n:::\n\n```{.r .cell-code}\n ### Observing staining differences between samples or batches of samples\nmulti_dittoPlot(\n    spe, \n    vars = rownames(spe)[rowData(spe)$use_channel],\n    group.by = \"patient_id\", plots = \"ridgeplot\", \n    assay = \"exprs\", \n    color.panel = metadata(spe)$color_vectors$patient_id\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0118\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0247\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0809\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0408\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.163\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0766\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.083\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0675\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.105\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0795\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0444\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.107\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0599\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0992\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0211\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.11\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0364\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0901\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.119\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0582\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0542\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0804\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.106\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0306\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0469\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0825\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0485\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0845\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.111\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.081\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0939\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0973\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.15\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.173\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0642\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0987\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0117\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: No shared levels found between `names(values)` of the manual scale and the\ndata's colour values.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-17-4.png){width=672}\n:::\n\n```{.r .cell-code}\nset.seed(220225)\nspe <- scater::runUMAP(\n    spe, subset_row = rowData(spe)$use_channel, exprs_values = \"exprs\"\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nAlso defined by 'spam'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nAlso defined by 'spam'\n```\n:::\n\n```{.r .cell-code}\nspe <- scater::runTSNE(\n    spe, subset_row = rowData(spe)$use_channel, exprs_values = \"exprs\"\n)\n\nreducedDims(spe)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of length 9\nnames(9): UMAP TSNE fastMNN ... UMAP_harmony seurat UMAP_seurat\n```\n:::\n\n```{.r .cell-code}\nhead(reducedDim(spe, \"UMAP\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                   UMAP1     UMAP2\nPatient1_001_1 -4.965459 -2.914412\nPatient1_001_2 -4.336567 -2.855069\nPatient1_001_3 -4.357023 -2.846398\nPatient1_001_4 -3.930147 -2.693578\nPatient1_001_5 -6.713229 -1.826328\nPatient1_001_6 -6.416659 -2.157444\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### visualize patient id \np1 <- dittoDimPlot(\n    spe, var = \"patient_id\", reduction.use = \"UMAP\", size = 0.2\n    ) + \n    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +\n    ggtitle(\"Patient ID on UMAP\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\np2 <- dittoDimPlot(\n    spe, var = \"patient_id\", reduction.use = \"TSNE\", size = 0.2\n    ) + \n    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +\n    ggtitle(\"Patient ID on TSNE\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\n### visualize region of interest id\np3 <- dittoDimPlot(\n    spe, var = \"ROI\", reduction.use = \"UMAP\", size = 0.2\n    ) + \n    scale_color_manual(values = metadata(spe)$color_vectors$ROI) +\n    ggtitle(\"ROI ID on UMAP\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\np4 <- dittoDimPlot(\n    spe, var = \"ROI\", reduction.use = \"TSNE\", size = 0.2\n    ) + \n    scale_color_manual(values = metadata(spe)$color_vectors$ROI) +\n    ggtitle(\"ROI ID on TSNE\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\n### visualize indication\np5 <- dittoDimPlot(\n    spe, var = \"indication\", reduction.use = \"UMAP\", size = 0.2\n    ) + \n    scale_color_manual(values = metadata(spe)$color_vectors$indication) +\n    ggtitle(\"Indication on UMAP\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\np6 <- dittoDimPlot(\n    spe, var = \"indication\", reduction.use = \"TSNE\", size = 0.2\n    ) + \n    scale_color_manual(values = metadata(spe)$color_vectors$indication) +\n    ggtitle(\"Indication on TSNE\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\n(p1 + p2) / (p3 + p4) / (p5 + p6)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### visualize marker expression\np1 <- dittoDimPlot(\n        spe, var = \"Ecad\", reduction.use = \"UMAP\", \n        assay = \"exprs\", size = 0.2\n    ) +\n    scale_color_viridis(name = \"Ecad\") +\n    ggtitle(\"E-Cadherin expression on UMAP\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\np2 <- dittoDimPlot(\n    spe, var = \"CD45RO\", reduction.use = \"UMAP\", \n    assay = \"exprs\", size = 0.2\n    ) +\n    scale_color_viridis(name = \"CD45RO\") +\n    ggtitle(\"CD45RO expression on UMAP\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\np3 <- dittoDimPlot(\n    spe, var = \"Ecad\", reduction.use = \"TSNE\", \n    assay = \"exprs\", size = 0.2\n    ) +\n    scale_color_viridis(name = \"Ecad\") +\n    ggtitle(\"Ecad expression on TSNE\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\np4 <- dittoDimPlot(\n    spe, var = \"CD45RO\", reduction.use = \"TSNE\", \n    assay = \"exprs\", size = 0.2\n    ) +\n    scale_color_viridis(name = \"CD45RO\") +\n    ggtitle(\"CD45RO expression on TSNE\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\n(p1 + p2) / (p3 + p4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-note}\nWe observe a strong separation of tumor cells (Ecad+ cells) between the patients. Here, each patient was diagnosed with a different tumor type. The separation of tumor cells could be of biological origin since tumor cells tend to display differences in expression between patients and cancer types and/or of technical origin: the panel only contains a single tumor marker (E-Cadherin) and therefore slight technical differences in staining causes visible separation between cells of different patients. Nevertheless, the immune compartment (CD45RO+ cells) mix between patients and we can rule out systematic staining differences between patients.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Save objects for further downstream analysis\nqsave(spe, here(dir, \"data/spe.qs\"))\n```\n:::\n\n\n## Batch effect  correction\n\n### fastMNN correction\n\n\n::: {.cell}\n\n```{.r .cell-code}\nspe <- qread(here(dir, \"data/spe.qs\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Perform sample correction\nset.seed(220228)\nout <- batchelor::fastMNN(\n    spe, \n    batch = spe$patient_id,\n    auto.merge = TRUE,\n    subset.row = rowData(spe)$use_channel,\n    assay.type = \"exprs\"\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in check_numbers(k = k, nu = nu, nv = nv, limit = min(dim(x)) - : more\nsingular values/vectors requested than available\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in (function (A, nv = 5, nu = nv, maxit = 1000, work = nv + 7, reorth =\nTRUE, : You're computing too large a percentage of total singular values, use a\nstandard svd instead.\n```\n:::\n\n```{.r .cell-code}\n### Check that order of cells is the same\nstopifnot(all.equal(colnames(spe), colnames(out)))\n\n### Transfer the correction results to the main spe object\nreducedDim(spe, \"fastMNN\") <- reducedDim(out, \"corrected\")\n\n### Quality control of correction results\nmerge_info <- metadata(out)$merge.info \n\n### 1. We observe that Patient4 and Patient2 are most similar with a low batch effect. \n### 2. Merging cells of Patient3 into the combined batch of Patient1, Patient2 \n### and Patient4 resulted in the highest percentage of lost variance and the \n### detection of the largest batch effect. \nmerge_info[, c(\"left\", \"right\", \"batch.size\")]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 3 rows and 3 columns\n                        left    right batch.size\n                      <List>   <List>  <numeric>\n1                   Patient4 Patient2   0.366641\n2          Patient4,Patient2 Patient1   0.541466\n3 Patient4,Patient2,Patient1 Patient3   0.749047\n```\n:::\n\n```{.r .cell-code}\nmerge_info$lost.var\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n        Patient1    Patient2   Patient3    Patient4\n[1,] 0.000000000 0.030385015 0.00000000 0.048613071\n[2,] 0.042567359 0.007911340 0.00000000 0.011963319\n[3,] 0.007594552 0.003602307 0.07579009 0.006601185\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Recompute the UMAP embedding using the corrected low-dimensional \n### coordinates for each cell.\nset.seed(220228)\nspe <- scater::runUMAP(spe, dimred= \"fastMNN\", name = \"UMAP_mnnCorrected\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nAlso defined by 'spam'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nAlso defined by 'spam'\n```\n:::\n\n```{.r .cell-code}\n### Visualize patient id \np1 <- dittoDimPlot(\n    spe, var = \"patient_id\", reduction.use = \"UMAP\", size = 0.2\n    ) + \n    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +\n    ggtitle(\"Patient ID on UMAP before correction\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\np2 <- dittoDimPlot(\n    spe, var = \"patient_id\", reduction.use = \"UMAP_mnnCorrected\", size = 0.2\n    ) + \n    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +\n    ggtitle(\"Patient ID on UMAP after correction\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\n### We observe an imperfect merging of Patient3 into all other samples. \n### This was already seen when displaying the merging information above. \ncowplot::plot_grid(p1, p2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-23-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Visualize the expression of selected markers across all cells before and \n### after batch correction\nmarkers <- c(\n    \"Ecad\", \"CD45RO\", \"CD20\", \"CD3\", \"FOXP3\", \"CD206\", \"MPO\", \"SMA\", \"Ki67\"\n)\n\n### Before correction\nplot_list <- multi_dittoDimPlot(\n    spe, var = markers, reduction.use = \"UMAP\", \n    assay = \"exprs\", size = 0.2, list.out = TRUE\n    )\n\nplot_list <- lapply(plot_list, function(x) x + scale_color_viridis())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\ncowplot::plot_grid(plotlist = plot_list)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### After correction\nplot_list <- multi_dittoDimPlot(\n    spe, var = markers, reduction.use = \"UMAP_mnnCorrected\", \n    assay = \"exprs\", size = 0.2, list.out = TRUE\n    ) \nplot_list <- lapply(plot_list, function(x) x + scale_color_viridis())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\n### We observe that immune cells across patients are merged after batch \n### correction using fastMNN. However, the tumor cells of different patients \n### still cluster separately.\ncowplot::plot_grid(plotlist = plot_list) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-24-2.png){width=672}\n:::\n:::\n\n\n### harmony correction\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### harmony returns the corrected low-dimensional coordinates for each cell\nspe <- runPCA(\n    spe, \n    subset_row = rowData(spe)$use_channel, \n    exprs_values = \"exprs\", \n    ncomponents = 30,\n    BSPARAM = ExactParam()\n)\n\nset.seed(230616)\nout <- RunHarmony(spe, group.by.vars = \"patient_id\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nTransposing data matrix\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nInitializing state using k-means centroids initialization\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nHarmony 1/10\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nHarmony 2/10\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nHarmony 3/10\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nHarmony 4/10\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nHarmony 5/10\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nHarmony converged after 5 iterations\n```\n:::\n\n```{.r .cell-code}\n### Check that order of cells is the same\nstopifnot(all.equal(colnames(spe), colnames(out)))\n\nreducedDim(spe, \"harmony\") <- reducedDim(out, \"HARMONY\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(220228)\nspe <- runUMAP(spe, dimred = \"harmony\", name = \"UMAP_harmony\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nAlso defined by 'spam'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nAlso defined by 'spam'\n```\n:::\n\n```{.r .cell-code}\n### visualize patient id\np1 <- dittoDimPlot(\n    spe, var = \"patient_id\", reduction.use = \"UMAP\", size = 0.2\n) +\n    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +\n    ggtitle(\"Patient ID on UMAP before correction\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\np2 <- dittoDimPlot(\n    spe, var = \"patient_id\", reduction.use = \"UMAP_harmony\", size = 0.2\n) +\n    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +\n    ggtitle(\"Patient ID on UMAP after correction\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\nplot_grid(p1, p2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### Visualize selected marker expression\n### Before correction\nplot_list <- multi_dittoDimPlot(\n    spe, var = markers, reduction.use = \"UMAP\",\n    assay = \"exprs\", size = 0.2, list.out = TRUE\n)\n\nplot_list <- lapply(plot_list, function(x) x + scale_color_viridis())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\nplot_grid(plotlist = plot_list)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-2.png){width=672}\n:::\n\n```{.r .cell-code}\n### After correction\nplot_list <- multi_dittoDimPlot(\n    spe, var = markers, reduction.use = \"UMAP_harmony\",\n    assay = \"exprs\", size = 0.2, list.out = TRUE\n)\nplot_list <- lapply(plot_list, function(x) x + scale_color_viridis())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\n### We observe a more aggressive merging of cells from different patients \n### compared to the results after fastMNN correction. Importantly, immune cell \n### and epithelial markers are expressed in distinct regions of the UMAP.\nplot_grid(plotlist = plot_list) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-26-3.png){width=672}\n:::\n:::\n\n### Seurat correction\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseurat_obj <- as.Seurat(spe, counts = \"counts\", data = \"exprs\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Keys should be one or more alphanumeric characters followed by an\nunderscore, setting key from UMAP to UMAP_\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Keys should be one or more alphanumeric characters followed by an\nunderscore, setting key from TSNE to TSNE_\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Keys should be one or more alphanumeric characters followed by an\nunderscore, setting key from UMAP to UMAP_\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Key 'UMAP_' taken, using 'umapmnncorrected_' instead\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Keys should be one or more alphanumeric characters followed by an\nunderscore, setting key from PC to PC_\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Keys should be one or more alphanumeric characters followed by an\nunderscore, setting key from UMAP to UMAP_\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Key 'UMAP_' taken, using 'umapharmony_' instead\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Key 'PC_' taken, using 'seurat_' instead\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Keys should be one or more alphanumeric characters followed by an\nunderscore, setting key from UMAP to UMAP_\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Key 'UMAP_' taken, using 'umapseurat_' instead\n```\n:::\n\n```{.r .cell-code}\nseurat_obj <- AddMetaData(seurat_obj, as.data.frame(colData(spe)))\nseurat_list <- SplitObject(seurat_obj, split.by = \"patient_id\")\n\n### Define the features used for integration and perform PCA on cells of each\n### patient individually\nfeatures <- rownames(spe)[rowData(spe)$use_channel]\n\nseurat_list <- lapply(\n    X = seurat_list,\n    FUN = function(x) {\n        x <- ScaleData(x, features = features, verbose = FALSE)\n        x <- RunPCA(x, features = features, verbose = FALSE, approx = FALSE)\n        return(x)\n    }\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Key 'PC_' taken, using 'pca_' instead\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Key 'PC_' taken, using 'pca_' instead\nKey 'PC_' taken, using 'pca_' instead\nKey 'PC_' taken, using 'pca_' instead\n```\n:::\n\n```{.r .cell-code}\nanchors <- FindIntegrationAnchors(\n    object.list = seurat_list,\n    anchor.features = features,\n    reduction = \"rpca\",\n    k.anchor = 20\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScaling features for provided objects\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nComputing within dataset neighborhoods\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding all pairwise anchors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nProjecting new data onto SVD\nProjecting new data onto SVD\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding neighborhoods\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding anchors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tFound 53333 anchors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nProjecting new data onto SVD\nProjecting new data onto SVD\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding neighborhoods\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding anchors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tFound 47418 anchors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nProjecting new data onto SVD\nProjecting new data onto SVD\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding neighborhoods\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding anchors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tFound 46957 anchors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nProjecting new data onto SVD\nProjecting new data onto SVD\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding neighborhoods\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding anchors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tFound 55977 anchors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nProjecting new data onto SVD\nProjecting new data onto SVD\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding neighborhoods\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding anchors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tFound 67563 anchors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nProjecting new data onto SVD\nProjecting new data onto SVD\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding neighborhoods\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding anchors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\tFound 52131 anchors\n```\n:::\n\n```{.r .cell-code}\ncombined <- IntegrateData(anchorset = anchors)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nMerging dataset 2 into 4\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nExtracting anchors for merged samples\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding integration vectors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in irlba(A = t(x = object), nv = npcs, ...): You're computing too large\na percentage of total singular values, use a standard svd instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding integration vector weights\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nIntegrating data\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nMerging dataset 1 into 4 2\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nExtracting anchors for merged samples\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding integration vectors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in irlba(A = t(x = object), nv = npcs, ...): You're computing too large\na percentage of total singular values, use a standard svd instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding integration vector weights\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nIntegrating data\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nMerging dataset 3 into 4 2 1\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nExtracting anchors for merged samples\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding integration vectors\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in irlba(A = t(x = object), nv = npcs, ...): You're computing too large\na percentage of total singular values, use a standard svd instead.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFinding integration vector weights\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nIntegrating data\n```\n:::\n\n```{.r .cell-code}\nDefaultAssay(combined) <- \"integrated\"\n\ncombined <- ScaleData(combined, verbose = FALSE)\ncombined <- RunPCA(combined, npcs = 30, verbose = FALSE, approx = FALSE)\n\n### Check that order of cells is the same\nstopifnot(all.equal(colnames(spe), colnames(combined)))\n\nreducedDim(spe, \"seurat\") <- Embeddings(combined, reduction = \"pca\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(220228)\nspe <- runUMAP(spe, dimred = \"seurat\", name = \"UMAP_seurat\") \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nAlso defined by 'spam'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nFound more than one class \"dist\" in cache; using the first, from namespace 'BiocGenerics'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nAlso defined by 'spam'\n```\n:::\n\n```{.r .cell-code}\n### Visualize patient id \np1 <- dittoDimPlot(\n        spe, var = \"patient_id\", \n        reduction.use = \"UMAP\", size = 0.2\n    ) + \n    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +\n    ggtitle(\"Patient ID on UMAP before correction\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\np2 <- dittoDimPlot(\n        spe, var = \"patient_id\", \n        reduction.use = \"UMAP_seurat\", size = 0.2\n    ) + \n    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +\n    ggtitle(\"Patient ID on UMAP after correction\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\nplot_grid(p1, p2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### Before correction\nplot_list <- multi_dittoDimPlot(\n    spe, var = markers, reduction.use = \"UMAP\", \n    assay = \"exprs\", size = 0.2, list.out = TRUE\n    ) \nplot_list <- lapply(plot_list, function(x) x + scale_color_viridis())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\nplot_grid(plotlist = plot_list)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-2.png){width=672}\n:::\n\n```{.r .cell-code}\n### After correction\nplot_list <- multi_dittoDimPlot(\n    spe, var = markers, reduction.use = \"UMAP_seurat\", \n    assay = \"exprs\", size = 0.2, list.out = TRUE\n    ) \n\nplot_list <- lapply(plot_list, function(x) x + scale_color_viridis())\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\n### Similar to the methods presented above, Seurat integrates immune cells \n### correctly. When visualizing the patient IDs, slight patient-to-patient \n### differences within tumor cells can be detected.\nplot_grid(plotlist = plot_list) \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-28-3.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Save modified object\nqsave(spe, here(dir, \"data/spe.qs\"))\n```\n:::\n\n## Cell phenotyping\n\nA common step during single-cell data analysis is the annotation of cells based on their phenotype. Defining cell phenotypes is often subjective and relies on previous biological knowledge. \n\nIn highly-multiplexed imaging, target proteins or molecules are manually selected based on the biological question at hand. It narrows down the feature space and facilitates the manual annotation of clusters to derive cell phenotypes. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nspe <- qread(here(dir, \"data/spe.qs\"))\n\n###  Sample 2000 cells to visualize cluster membership.\nset.seed(220619)\ncur_cells <- sample(seq_len(ncol(spe)), 2000)\n```\n:::\n\n\n### Rphenograph\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- t(assay(spe, \"exprs\")[rowData(spe)$use_channel, ])\n\nset.seed(230619)\nout <- Rphenograph(mat, k = 45)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRun Rphenograph starts:\n  -Input data of 47794 rows and 37 columns\n  -k is set to 45\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  Finding nearest neighbors...DONE ~ 57.221 s\n  Compute jaccard coefficient between nearest-neighbor sets...DONE ~ 20.057 s\n  Build undirected graph from the weighted links...DONE ~ 2.609 s\n  Run louvain clustering on the graph ...DONE ~ 5.252 s\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nRun Rphenograph DONE, totally takes 85.139s.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  Return a community class\n  -Modularity value: 0.8620567 \n  -Number of clusters: 24\n```\n:::\n\n```{.r .cell-code}\nclusters <- factor(membership(out[[2]]))\n\nspe$pg_clusters <- clusters\n\ndittoDimPlot(\n    spe, var = \"pg_clusters\",\n    reduction.use = \"UMAP\", size = 0.2,\n    do.label = TRUE\n) +\n    ggtitle(\"Phenograph clusters on UMAP\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### We can observe that some of the clusters only contain cells of a single \n### patient. This can often be observed in the tumor compartment.\ndittoHeatmap(\n    spe[, cur_cells],\n    genes = rownames(spe)[rowData(spe)$use_channel],\n    assay = \"exprs\", scale = \"none\",\n    heatmap.colors = viridis(100),\n    annot.by = c(\"pg_clusters\", \"patient_id\"),\n    annot.colors = c(\n        dittoColors(1)[1:length(unique(spe$pg_clusters))],\n        metadata(spe)$color_vectors$patient_id\n    )\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-31-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Use the integrated cells in low dimensional embedding for clustering\nmat <- reducedDim(spe, \"fastMNN\")\n\nset.seed(230619)\nout <- Rphenograph(mat, k = 45)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRun Rphenograph starts:\n  -Input data of 47794 rows and 36 columns\n  -k is set to 45\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  Finding nearest neighbors...DONE ~ 51.466 s\n  Compute jaccard coefficient between nearest-neighbor sets...DONE ~ 20.096 s\n  Build undirected graph from the weighted links...DONE ~ 2.728 s\n  Run louvain clustering on the graph ...DONE ~ 7.708 s\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nRun Rphenograph DONE, totally takes 81.998s.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n  Return a community class\n  -Modularity value: 0.8453626 \n  -Number of clusters: 25\n```\n:::\n\n```{.r .cell-code}\nclusters <- factor(membership(out[[2]]))\n\nspe$pg_clusters_corrected <- clusters\n\ndittoDimPlot(\n    spe, var = \"pg_clusters_corrected\",\n    reduction.use = \"UMAP_mnnCorrected\", size = 0.2,\n    do.label = TRUE\n) +\n    ggtitle(\"Phenograph clusters on UMAP, integrated cells\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### Clustering using the integrated embedding leads to clusters that contain \n### cells of different patients. \ndittoHeatmap(\n    spe[, cur_cells],\n    genes = rownames(spe)[rowData(spe)$use_channel],\n    assay = \"exprs\", scale = \"none\",\n    heatmap.colors = viridis(100),\n    annot.by = c(\"pg_clusters_corrected\", \"patient_id\"),\n    annot.colors = c(dittoColors(1)[1:length(unique(spe$pg_clusters_corrected))],\n        metadata(spe)$color_vectors$patient_id)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-32-2.png){width=672}\n:::\n:::\n\n\n### Shared nearest neighbour graph\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- t(assay(spe, \"exprs\")[rowData(spe)$use_channel, ])\n\ncombinations <- clusterSweep(\n    mat,\n    BLUSPARAM = SNNGraphParam(),\n    k = c(10L, 20L),\n    type = c(\"rank\", \"jaccard\"),\n    cluster.fun = \"louvain\",\n    BPPARAM = MulticoreParam(RNGseed = 220427)\n)\n\nsil <- vapply(\n    as.list(combinations$clusters),\n    function(x) mean(approxSilhouette(mat, x)$width),\n    0\n)\n\nggplot(\n    data.frame(method = names(sil),\n    sil = sil)\n    ) +\n    geom_point(aes(method, sil)) +\n    theme_classic(base_size = 15) +\n    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +\n    xlab(\"Cluster parameter combination\") +\n    ylab(\"Average silhouette width\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n\n```{.r .cell-code}\npur <- vapply(\n    as.list(combinations$clusters), \n    function(x) mean(neighborPurity(mat, x)$purity), \n    0\n)\n\nggplot(\n    data.frame(method = names(pur), pur = pur)\n    ) +\n    geom_point(aes(method, pur)) +\n    theme_classic(base_size = 15) +\n    theme(axis.text.x = element_text(angle = 90, hjust = 1)) +\n    xlab(\"Cluster parameter combination\") +\n    ylab(\"Average neighborhood purity\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-33-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(220620)\nclusters <- clusterCells(\n    spe[rowData(spe)$use_channel,], \n    assay.type = \"exprs\", \n    BLUSPARAM = SNNGraphParam(k=20, \n    cluster.fun = \"louvain\",\n    type = \"rank\")\n)\n\nspe$nn_clusters <- clusters\n\ndittoDimPlot(\n    spe, var = \"nn_clusters\", \n    reduction.use = \"UMAP\", size = 0.2,\n    do.label = TRUE\n    ) +\n    ggtitle(\"SNN clusters on UMAP\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n\n```{.r .cell-code}\ndittoHeatmap(\n    spe[,cur_cells], \n             genes = rownames(spe)[rowData(spe)$use_channel],\n             assay = \"exprs\", scale = \"none\",\n             heatmap.colors = viridis(100), \n             annot.by = c(\"nn_clusters\", \"patient_id\"),\n             annot.colors = c(dittoColors(1)[1:length(unique(spe$nn_clusters))],\n                              metadata(spe)$color_vectors$patient_id)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-34-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(220621)\nclusters <- clusterCells(\n    spe, \n    use.dimred = \"fastMNN\", \n    BLUSPARAM = SNNGraphParam(k = 20, \n    cluster.fun = \"louvain\",\n    type = \"rank\")\n)\n\nspe$nn_clusters_corrected <- clusters\n\ndittoDimPlot(\n    spe, var = \"nn_clusters_corrected\", \n    reduction.use = \"UMAP_mnnCorrected\", size = 0.2,\n    do.label = TRUE\n) +\n    ggtitle(\"SNN clusters on UMAP, integrated cells\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n\n```{.r .cell-code}\ndittoHeatmap(\n    spe[,cur_cells], \n    genes = rownames(spe)[rowData(spe)$use_channel],\n    assay = \"exprs\", scale = \"none\",\n    heatmap.colors = viridis(100), \n    annot.by = c(\"nn_clusters_corrected\",\"patient_id\"),\n    annot.colors = c(dittoColors(1)[1:length(unique(spe$nn_clusters_corrected))],\n                    metadata(spe)$color_vectors$patient_id)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-35-2.png){width=672}\n:::\n:::\n\n\n### Self organizing maps\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Run FlowSOM and ConsensusClusterPlus clustering\nset.seed(220410)\nspe <- CATALYST::cluster(spe, \n               features = rownames(spe)[rowData(spe)$use_channel],\n               maxK = 30)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\no running FlowSOM clustering...\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\no running ConsensusClusterPlus metaclustering...\n```\n:::\n\n```{.r .cell-code}\n# Assess cluster stability\ndelta_area(spe)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-1.png){width=672}\n:::\n\n```{.r .cell-code}\nspe$som_clusters <- cluster_ids(spe, \"meta13\")\n\ndittoDimPlot(\n    spe, var = \"som_clusters\", \n    reduction.use = \"UMAP\", size = 0.2,\n    do.label = TRUE\n    ) +\n    ggtitle(\"SOM clusters on UMAP\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-2.png){width=672}\n:::\n\n```{.r .cell-code}\ndittoHeatmap(\n    spe[,cur_cells], \n    genes = rownames(spe)[rowData(spe)$use_channel],\n    assay = \"exprs\", scale = \"none\",\n    heatmap.colors = viridis(100), \n    annot.by = c(\"som_clusters\", \"patient_id\"),\n    annot.colors = c(dittoColors(1)[1:length(unique(spe$som_clusters))],\n    metadata(spe)$color_vectors$patient_id)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-3.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(kohonen)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'kohonen'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:mclust':\n\n    map\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:purrr':\n\n    map\n```\n:::\n\n```{.r .cell-code}\nlibrary(ConsensusClusterPlus)\n\n### Select integrated cells\nmat <- reducedDim(spe, \"fastMNN\")\n\n### Perform SOM clustering\nset.seed(220410)\nsom.out <- clusterRows(mat, SomParam(100), full = TRUE)\n\n### Cluster the 100 SOM codes into larger clusters\nccp <- ConsensusClusterPlus(\n    t(som.out$objects$som$codes[[1]]),\n    maxK = 30,\n    reps = 100, \n    distance = \"euclidean\", \n    seed = 220410, \n    plot = NULL\n)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nend fraction\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-2.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-3.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-4.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-5.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-6.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-7.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-8.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-9.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-10.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-11.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-12.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-13.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-14.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-15.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-16.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-17.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-18.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-19.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-20.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-21.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-22.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-23.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-24.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-25.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-26.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-27.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-28.png){width=672}\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nclustered\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-29.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-30.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-31.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-32.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-33.png){width=672}\n:::\n\n```{.r .cell-code}\n### Visualize delta area plot\nCATALYST:::.plot_delta_area(ccp)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-34.png){width=672}\n:::\n\n```{.r .cell-code}\n### Link ConsensusClusterPlus clusters with SOM codes and save in object\nsom.cluster <- ccp[[16]][[\"consensusClass\"]][som.out$clusters]\nspe$som_clusters_corrected <- as.factor(som.cluster)\n\ndittoDimPlot(\n    spe, var = \"som_clusters_corrected\", \n    reduction.use = \"UMAP_mnnCorrected\", size = 0.2,\n    do.label = TRUE\n    ) +\n    ggtitle(\"SOM clusters on UMAP, integrated cells\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-35.png){width=672}\n:::\n\n```{.r .cell-code}\ndittoHeatmap(\n    spe[,cur_cells], \n    genes = rownames(spe)[rowData(spe)$use_channel],\n    assay = \"exprs\", scale = \"none\",\n    heatmap.colors = viridis(100), \n    annot.by = c(\"som_clusters_corrected\",\"patient_id\"),\n    annot.colors = c(dittoColors(1)[1:length(unique(spe$som_clusters_corrected))],\n                              metadata(spe)$color_vectors$patient_id)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-37-36.png){width=672}\n:::\n:::\n\n\n### Compare between clustering approaches\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patchwork)\nlibrary(pheatmap)\nlibrary(gridExtra)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'gridExtra'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:EBImage':\n\n    combine\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:Biobase':\n\n    combine\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:BiocGenerics':\n\n    combine\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:dplyr':\n\n    combine\n```\n:::\n\n```{.r .cell-code}\ntab1 <- table(\n    paste(\"Rphenograph\", spe$pg_clusters), \n    paste(\"SNN\", spe$nn_clusters)\n)\n\ntab2 <- table(\n    paste(\"Rphenograph\", spe$pg_clusters), \n    paste(\"SOM\", spe$som_clusters)\n)\n\ntab3 <- table(\n    paste(\"SNN\", spe$nn_clusters), \n    paste(\"SOM\", spe$som_clusters)\n)\n\npheatmap(log10(tab1 + 10), color = viridis(100))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n\n```{.r .cell-code}\npheatmap(log10(tab2 + 10), color = viridis(100))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-2.png){width=672}\n:::\n\n```{.r .cell-code}\npheatmap(log10(tab3 + 10), color = viridis(100))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-38-3.png){width=672}\n:::\n:::\n\n\n### Further clustering notes\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\ncluster_celltype <- recode(spe$nn_clusters_corrected,\n                            \"1\" = \"Tumor_proliferating\",\n                            \"2\" = \"Myeloid\",\n                            \"3\" = \"Tumor\",\n                            \"4\" = \"Tumor\",\n                            \"5\" = \"Stroma\",\n                            \"6\" = \"Proliferating\",\n                            \"7\" = \"Myeloid\",\n                            \"8\" = \"Plasma_cell\",\n                            \"9\" = \"CD8\",\n                            \"10\" = \"CD4\",\n                            \"11\" = \"Neutrophil\",\n                            \"12\" = \"Bcell\",\n                            \"13\" = \"Stroma\")\n\nspe$cluster_celltype <- cluster_celltype\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nqsave(spe, here(dir, \"data/spe.qs\"))\n```\n:::\n\n\n### Classfication approach\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Manual labeling of cells\n# if (interactive()) {\n\n#     images <- qread(here(dir, \"data/images.qs\"))\n#     masks <- qread(here(dir, \"data/masks.qs\"))\n\n#     cytomapperShiny(object = spe, mask = masks, image = images,\n#                     cell_id = \"ObjectNumber\", img_id = \"sample_id\")\n# }\nspe <- qread(here(dir, \"data/spe.qs\"))\n### Define color vectors\ncelltype <- setNames(\n    c(\"#3F1B03\", \"#F4AD31\", \"#894F36\", \"#1C750C\", \"#EF8ECC\",\n        \"#6471E2\", \"#4DB23B\", \"grey\", \"#F4800C\", \"#BF0A3D\", \"#066970\"\n    ),\n    c(\"Tumor\", \"Stroma\", \"Myeloid\", \"CD8\", \"Plasma_cell\",\n        \"Treg\", \"CD4\", \"undefined\", \"BnTcell\", \"Bcell\", \"Neutrophil\")\n)\n\nmetadata(spe)$color_vectors$celltype <- celltype\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Read in and consolidate labeled data\nlabel_files <- list.files(\n    here(dir, \"data/gated_cells\"), \n    full.names = TRUE, pattern = \".rds$\"\n)\n\n### Read in SPE objects\nspes <- lapply(label_files, readRDS)\n\n### Merge SPE objects\nconcat_spe <- do.call(\"cbind\", spes)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n'sample_id's are duplicated across 'SpatialExperiment' objects to cbind; appending sample indices.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfilter_labels <- function(object, \n                          label = \"cytomapper_CellLabel\") {\n    cur_tab <- unclass(table(colnames(object), object[[label]]))\n    \n    cur_labels <- colnames(cur_tab)[apply(cur_tab, 1, which.max)]\n    names(cur_labels) <- rownames(cur_tab)\n    \n    cur_labels <- cur_labels[rowSums(cur_tab) == 1]\n    \n    return(cur_labels)\n}\n\nlabels <- filter_labels(concat_spe)\n\ncur_spe <- concat_spe[,concat_spe$cytomapper_CellLabel != \"Tumor\"]\n\nnon_tumor_labels <- filter_labels(cur_spe)\n\nadditional_cells <- setdiff(names(non_tumor_labels), names(labels))\n\nfinal_labels <- c(labels, non_tumor_labels[additional_cells])\n\n### Transfer labels to SPE object\nspe_labels <- rep(\"unlabeled\", ncol(spe))\nnames(spe_labels) <- colnames(spe)\nspe_labels[names(final_labels)] <- final_labels\nspe$cell_labels <- spe_labels\n\n### Number of cells labeled per patient\ntable(spe$cell_labels, spe$patient_id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             \n              Patient1 Patient2 Patient3 Patient4\n  Bcell            152      131      234      263\n  BnTcell          396       37      240     1029\n  CD4               45      342      167      134\n  CD8               60      497      137      128\n  Myeloid          183      378      672      517\n  Neutrophil        97        4       17       16\n  Plasma_cell       34      536       87       59\n  Stroma            84       37       85      236\n  Treg             139      149       49       24\n  Tumor           2342      906     1618     1133\n  unlabeled       7214     9780     7826     9580\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Split between labeled and unlabeled cells\nlab_spe <- spe[,spe$cell_labels != \"unlabeled\"]\nunlab_spe <- spe[,spe$cell_labels == \"unlabeled\"]\n\n### Randomly split into train and test data\nset.seed(221029)\ntrainIndex <- createDataPartition(factor(lab_spe$cell_labels), p = 0.75)\n\ntrain_spe <- lab_spe[,trainIndex$Resample1]\ntest_spe <- lab_spe[,-trainIndex$Resample1]\n\n### Define fit parameters for 5-fold cross validation\nfitControl <- trainControl(method = \"cv\",number = 5)\n\n### Select the arsinh-transformed counts for training\ncur_mat <- t(assay(train_spe, \"exprs\")[rowData(train_spe)$use_channel,])\n\n### Train a random forest classifier\nrffit <- train(\n    x = cur_mat, \n    y = factor(train_spe$cell_labels),\n    method = \"rf\", ntree = 1000,\n    tuneLength = 5,\n    trControl = fitControl\n)\n\nrffit\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRandom Forest \n\n10049 samples\n   37 predictor\n   10 classes: 'Bcell', 'BnTcell', 'CD4', 'CD8', 'Myeloid', 'Neutrophil', 'Plasma_cell', 'Stroma', 'Treg', 'Tumor' \n\nNo pre-processing\nResampling: Cross-Validated (5 fold) \nSummary of sample sizes: 8040, 8039, 8038, 8038, 8041 \nResampling results across tuning parameters:\n\n  mtry  Accuracy   Kappa    \n   2    0.9643721  0.9523612\n  10    0.9754201  0.9672910\n  19    0.9757188  0.9676911\n  28    0.9751223  0.9668928\n  37    0.9735309  0.9647805\n\nAccuracy was used to select the optimal model using the largest value.\nThe final value used for the model was mtry = 19.\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Classifier performance\nggplot(rffit) + \n  geom_errorbar(data = rffit$results,\n                aes(ymin = Accuracy - AccuracySD,\n                    ymax = Accuracy + AccuracySD),\n                width = 0.4) +\n    theme_classic(base_size = 15)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-45-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### Visualize the variable importance of the classifier.\nplot(varImp(rffit))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-45-2.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Select the arsinh-transformed counts of the test data\ncur_mat <- t(assay(test_spe, \"exprs\")[rowData(test_spe)$use_channel,])\n\n### Predict the cell phenotype labels of the test data\nset.seed(231019)\ncur_pred <- predict(rffit, newdata = cur_mat)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncm <- confusionMatrix(\n    data = cur_pred, \n    reference = factor(test_spe$cell_labels), \n    mode = \"everything\"\n)\n\ncm\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nConfusion Matrix and Statistics\n\n             Reference\nPrediction    Bcell BnTcell  CD4  CD8 Myeloid Neutrophil Plasma_cell Stroma\n  Bcell         185       4    0    0       0          0           5      0\n  BnTcell         3     421    2    1       0          0           1      0\n  CD4             0       0  161    0       0          2           4      2\n  CD8             0       0    0  197       0          0           7      0\n  Myeloid         0       0    2    3     437          0           0      0\n  Neutrophil      0       0    0    0       0         30           0      0\n  Plasma_cell     0       0    4    1       0          0         158      0\n  Stroma          0       0    2    0       0          0           0    108\n  Treg            0       0    0    0       0          0           3      0\n  Tumor           7       0    1    3       0          1           1      0\n             Reference\nPrediction    Treg Tumor\n  Bcell          0     0\n  BnTcell        0     0\n  CD4            0     4\n  CD8            1     5\n  Myeloid        0     0\n  Neutrophil     0     0\n  Plasma_cell    0     0\n  Stroma         0     0\n  Treg          89     2\n  Tumor          0  1488\n\nOverall Statistics\n                                          \n               Accuracy : 0.9788          \n                 95% CI : (0.9733, 0.9834)\n    No Information Rate : 0.4481          \n    P-Value [Acc > NIR] : < 2.2e-16       \n                                          \n                  Kappa : 0.9717          \n                                          \n Mcnemar's Test P-Value : NA              \n\nStatistics by Class:\n\n                     Class: Bcell Class: BnTcell Class: CD4 Class: CD8\nSensitivity               0.94872         0.9906    0.93605    0.96098\nSpecificity               0.99714         0.9976    0.99622    0.99586\nPos Pred Value            0.95361         0.9836    0.93064    0.93810\nNeg Pred Value            0.99683         0.9986    0.99653    0.99745\nPrecision                 0.95361         0.9836    0.93064    0.93810\nRecall                    0.94872         0.9906    0.93605    0.96098\nF1                        0.95116         0.9871    0.93333    0.94940\nPrevalence                0.05830         0.1271    0.05142    0.06129\nDetection Rate            0.05531         0.1259    0.04813    0.05889\nDetection Prevalence      0.05800         0.1280    0.05172    0.06278\nBalanced Accuracy         0.97293         0.9941    0.96613    0.97842\n                     Class: Myeloid Class: Neutrophil Class: Plasma_cell\nSensitivity                  1.0000          0.909091            0.88268\nSpecificity                  0.9983          1.000000            0.99842\nPos Pred Value               0.9887          1.000000            0.96933\nNeg Pred Value               1.0000          0.999095            0.99340\nPrecision                    0.9887          1.000000            0.96933\nRecall                       1.0000          0.909091            0.88268\nF1                           0.9943          0.952381            0.92398\nPrevalence                   0.1306          0.009865            0.05351\nDetection Rate               0.1306          0.008969            0.04723\nDetection Prevalence         0.1321          0.008969            0.04873\nBalanced Accuracy            0.9991          0.954545            0.94055\n                     Class: Stroma Class: Treg Class: Tumor\nSensitivity                0.98182     0.98889       0.9927\nSpecificity                0.99938     0.99846       0.9930\nPos Pred Value             0.98182     0.94681       0.9913\nNeg Pred Value             0.99938     0.99969       0.9940\nPrecision                  0.98182     0.94681       0.9913\nRecall                     0.98182     0.98889       0.9927\nF1                         0.98182     0.96739       0.9920\nPrevalence                 0.03288     0.02691       0.4481\nDetection Rate             0.03229     0.02661       0.4448\nDetection Prevalence       0.03288     0.02810       0.4487\nBalanced Accuracy          0.99060     0.99368       0.9928\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(cm$byClass) |>\n  mutate(class = sub(\"Class: \", \"\", rownames(cm$byClass))) |>\n  ggplot() + \n  geom_point(aes(1 - Specificity, Sensitivity, \n                 size = Detection.Rate,\n                 fill = class),\n             shape = 21) + \n  scale_fill_manual(values = metadata(spe)$color_vectors$celltype) +\n  theme_classic(base_size = 15) + \n  ylab(\"Sensitivity (TPR)\") +\n  xlab(\"1 - Specificity (FPR)\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-48-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(231019)\ncur_pred <- predict(rffit, \n                    newdata = cur_mat, \n                    type = \"prob\")\ncur_pred$truth <- factor(test_spe$cell_labels)\n\ncur_pred |>\n  pivot_longer(cols = Bcell:Tumor) |>\n  ggplot() +\n  geom_boxplot(aes(x = name, y = value, fill = name), outlier.size = 0.5) +\n  facet_wrap(. ~ truth, ncol = 1) + \n  scale_fill_manual(values = metadata(spe)$color_vectors$celltype)  +\n  theme(\n    panel.background = element_blank(), \n    axis.text.x = element_text(angle = 45, hjust = 1)\n    )\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-49-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Classification of new data\n### Select the arsinh-transformed counts of the unlabeled data for prediction\ncur_mat <- t(assay(unlab_spe, \"exprs\")[rowData(unlab_spe)$use_channel,])\n\n### Predict the cell phenotype labels of the unlabeled data\nset.seed(231014)\ncell_class <- as.character(predict(\n    rffit, \n    newdata = cur_mat, \n    type = \"raw\")\n)\nnames(cell_class) <- rownames(cur_mat)\n\ntable(cell_class)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncell_class\n      Bcell     BnTcell         CD4         CD8     Myeloid  Neutrophil \n        799        1047        3664        2728        5726         453 \nPlasma_cell      Stroma        Treg       Tumor \n       3369        4669        1057       10888 \n```\n:::\n\n```{.r .cell-code}\n### Extract prediction probabilities for each cell\nset.seed(231014)\ncell_prob <- predict(rffit, newdata = cur_mat, type = \"prob\")\n\n### Distribution of maximum probabilities\ntibble(max_prob = rowMax(as.matrix(cell_prob)),\n       type = cell_class) |>\n    ggplot() +\n        geom_density_ridges(aes(x = max_prob, y = cell_class, fill = cell_class)) +\n        scale_fill_manual(values = metadata(spe)$color_vectors$celltype) +\n        theme_classic(base_size = 15) +\n        xlab(\"Maximum probability\") +\n        ylab(\"Cell type\") + \n        xlim(c(0,1.2))\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPicking joint bandwidth of 0.0281\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-50-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### Label undefined cells\ncell_class[rowMax(as.matrix(cell_prob)) < 0.4] <- \"undefined\"\n\n### Store labels in SpatialExperiment onject\ncell_labels <- spe$cell_labels\ncell_labels[colnames(unlab_spe)] <- cell_class\nspe$celltype <- cell_labels \n\ntable(spe$celltype, spe$patient_id)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n             \n              Patient1 Patient2 Patient3 Patient4\n  Bcell            179      517      422      460\n  BnTcell          422      601      604     1110\n  CD4              407     1383      700     1394\n  CD8              510     1370      478     1156\n  Myeloid         1210     1876     1599     2685\n  Neutrophil       284        6       92      164\n  Plasma_cell      809     2428      425      338\n  Stroma           582      603      662     3169\n  Treg             524      379      244      258\n  Tumor           5593     3360     5793     2117\n  undefined        226      274      113      268\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntab1 <- table(spe$celltype, \n              paste(\"Rphenograph\", spe$pg_clusters))\ntab2 <- table(spe$celltype, \n              paste(\"SNN\", spe$nn_clusters))\ntab3 <- table(spe$celltype, \n              paste(\"SOM\", spe$som_clusters))\n\npheatmap(log10(tab1 + 10), color = viridis(100))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-51-1.png){width=672}\n:::\n\n```{.r .cell-code}\npheatmap(log10(tab2 + 10), color = viridis(100))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-51-2.png){width=672}\n:::\n\n```{.r .cell-code}\npheatmap(log10(tab3 + 10), color = viridis(100))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-51-3.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ntab1 <- table(spe$celltype, \n              paste(\"Rphenograph\", spe$pg_clusters_corrected))\ntab2 <- table(spe$celltype, \n              paste(\"SNN\", spe$nn_clusters_corrected))\ntab3 <- table(spe$celltype, \n              paste(\"SOM\", spe$som_clusters_corrected))\n\npheatmap(log10(tab1 + 10), color = viridis(100))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-52-1.png){width=672}\n:::\n\n```{.r .cell-code}\npheatmap(log10(tab2 + 10), color = viridis(100))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-52-2.png){width=672}\n:::\n\n```{.r .cell-code}\npheatmap(log10(tab3 + 10), color = viridis(100))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-52-3.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nqsave(spe, here(dir, \"data/spe.qs\"))\n```\n:::\n\n\n## Single cell visualization\n\n### Inital setup\n\n::: {.cell}\n\n```{.r .cell-code}\nspe <- qread(here(dir, \"data/spe.qs\"))\nreducedDims(spe)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nList of length 9\nnames(9): UMAP TSNE fastMNN ... UMAP_harmony seurat UMAP_seurat\n```\n:::\n\n```{.r .cell-code}\ncolnames(colData(spe))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"sample_id\"              \"ObjectNumber\"           \"area\"                  \n [4] \"axis_major_length\"      \"axis_minor_length\"      \"eccentricity\"          \n [7] \"width_px\"               \"height_px\"              \"patient_id\"            \n[10] \"ROI\"                    \"indication\"             \"pg_clusters\"           \n[13] \"pg_clusters_corrected\"  \"nn_clusters\"            \"cluster_id\"            \n[16] \"som_clusters\"           \"som_clusters_corrected\" \"nn_clusters_corrected\" \n[19] \"cluster_celltype\"       \"cell_labels\"            \"celltype\"              \n```\n:::\n\n```{.r .cell-code}\n### Define cell phenotype markers\ntype_markers <- c(\n    \"Ecad\", \"CD45RO\", \"CD20\", \"CD3\", \"FOXP3\", \"CD206\", \"MPO\",\n    \"SMA\", \"CD8a\", \"CD4\", \"HLADR\", \"CD15\", \"CD38\", \"PDGFRb\"\n)\n\n### Define cell state markers\nstate_markers <- c(\n    \"CarbonicAnhydrase\", \"Ki67\", \"PD1\", \"GrzB\", \"PDL1\",\n    \"ICOS\", \"TCF7\", \"VISTA\"\n)\n\n### Add to spe\nrowData(spe)$marker_class <- ifelse(\n    rownames(spe) %in% type_markers, \"type\",\n    ifelse(rownames(spe) %in% state_markers, \"state\",\n        \"other\")\n)\n```\n:::\n\n### Cell-type level\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Dimensionality reduction visualization\n### Interpreting these UMAP, tSNE plots is not trivial, but local neighborhoods \n### in the plot can suggest similarity in expression for given cells.\n### tSNE/UMAP aim to preserve the distances between each cell and its neighbors in the high-dimensional space.\n\n### UMAP colored by cell type and expression - dittoDimPlot\np1 <- dittoDimPlot(\n    spe, \n    var = \"celltype\", \n    reduction.use = \"UMAP_mnnCorrected\", \n    size = 0.2,\n    do.label = TRUE\n) +\n  scale_color_manual(values = metadata(spe)$color_vectors$celltype) +\n  theme(legend.title = element_blank()) +\n  ggtitle(\"Cell types on UMAP, integrated cells\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\np2 <- dittoDimPlot(\n    spe, \n    var = \"Ecad\", \n    assay = \"exprs\",\n    reduction.use = \"UMAP_mnnCorrected\", \n    size = 0.2, \n    colors = viridis(100), \n    do.label = TRUE\n) +\n    scale_color_viridis()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\ndo.label was/were ignored for non-discrete data.\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\n    # coord_fixed()\n  \np1 + p2\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# UMAP colored by expression for all markers - plotReducedDim\nplot_list <- lapply(\n    rownames(spe)[rowData(spe)$marker_class == \"type\"],\n    function(x) {\n        p <- scater::plotReducedDim(\n            spe,\n            dimred = \"UMAP_mnnCorrected\",\n            colour_by = x,\n            by_exprs_values = \"exprs\",\n            point_size = 0.2\n        )\n        return(p)\n    }\n)\n\nplot_grid(plotlist = plot_list)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-56-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Heatmap visualization, it is often useful to visualize single-cell \n### expression per cell type in form of a heatmap\nset.seed(220818)\ncur_cells <- sample(seq_len(ncol(spe)), 4000)\n\n### Heatmap visualization\ndittoHeatmap(\n    spe[,cur_cells], \n    genes = rownames(spe)[rowData(spe)$marker_class == \"type\"],\n    assay = \"exprs\", \n    cluster_cols = FALSE, \n    scale = \"none\",\n    heatmap.colors = viridis(100), \n    annot.by = c(\"celltype\", \"indication\", \"patient_id\"),\n    annotation_colors = list(\n        indication = metadata(spe)$color_vectors$indication,\n        patient_id = metadata(spe)$color_vectors$patient_id,\n        celltype = metadata(spe)$color_vectors$celltype\n    )\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-57-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Visualize the mean marker expression per cell type for all cells\n### aggregate by cell type\ncelltype_mean <- scuttle::aggregateAcrossCells(\n    as(spe, \"SingleCellExperiment\"),  \n    ids = spe$celltype, \n    statistics = \"mean\",\n    use.assay.type = \"exprs\", \n    subset.row = rownames(spe)[rowData(spe)$marker_class == \"type\"]\n)\n\n### No scaling\ndittoHeatmap(\n    celltype_mean,\n    assay = \"exprs\", \n    cluster_cols = TRUE, \n    scale = \"none\",\n    heatmap.colors = viridis(100),\n    annot.by = c(\"celltype\", \"ncells\"),\n    annotation_colors = list(\n        celltype = metadata(spe)$color_vectors$celltype,\n        ncells = plasma(100)\n    )\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-58-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### Scaled to max\ndittoHeatmap(\n    celltype_mean,\n    assay = \"exprs\", \n    cluster_cols = TRUE, \n    scaled.to.max = TRUE,\n    heatmap.colors.max.scaled = inferno(100),\n    annot.by = c(\"celltype\", \"ncells\"),\n    annotation_colors = list(\n        celltype = metadata(spe)$color_vectors$celltype,\n        ncells = plasma(100)\n    )\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-58-2.png){width=672}\n:::\n\n```{.r .cell-code}\n### # Z score scaled\ndittoHeatmap(\n    celltype_mean,\n    assay = \"exprs\", \n    cluster_cols = TRUE, \n    annot.by = c(\"celltype\", \"ncells\"),\n    annotation_colors = list(\n        celltype = metadata(spe)$color_vectors$celltype,\n        ncells = plasma(100)\n    )\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-58-3.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Violin plot visualization - plotExpression\nplotExpression(\n    spe[,cur_cells], \n    features = rownames(spe)[rowData(spe)$marker_class == \"type\"],\n    x = \"celltype\", \n    exprs_values = \"exprs\", \n    colour_by = \"celltype\"\n) +\n    theme(axis.text.x =  element_text(angle = 90))+\n    scale_color_manual(values = metadata(spe)$color_vectors$celltype)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-59-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Scatter plot visualization\ndittoScatterPlot(\n    spe,\n    x.var = \"CD3\",\n    y.var = \"CD20\",\n    assay.x = \"exprs\",\n    assay.y = \"exprs\",\n    color.var = \"celltype\"\n) +\n    scale_color_manual(values = metadata(spe)$color_vectors$celltype) +\n    ggtitle(\"Scatterplot for CD3/CD20 labelled by celltype\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-60-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### by sample_id - percentage\ndittoBarPlot(spe, var = \"celltype\", group.by = \"sample_id\") +\n    scale_fill_manual(values = metadata(spe)$color_vectors$celltype)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-61-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### by patient_id - percentage\ndittoBarPlot(spe, var = \"celltype\", group.by = \"patient_id\") +\n    scale_fill_manual(values = metadata(spe)$color_vectors$celltype)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-61-2.png){width=672}\n:::\n\n```{.r .cell-code}\n### by patient_id - count\ndittoBarPlot(spe, scale = \"count\",var = \"celltype\", group.by = \"patient_id\") +\n    scale_fill_manual(values = metadata(spe)$color_vectors$celltype)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-61-3.png){width=672}\n:::\n\n```{.r .cell-code}\n### We can see that cell type frequencies change between samples/patients and that the highest proportion/counts of plasma cells and stromal cells can be observed for Patient 2 and Patient 4, respectively.\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### CATALYST-based visualization\n### Save SPE in CATALYST-compatible object with renamed colData entries and\n### new metadata information\nspe_cat <- spe\nspe_cat$sample_id <- factor(spe$sample_id)\nspe_cat$condition <- factor(spe$indication)\nspe_cat$cluster_id <- factor(spe$celltype)\n\n### Add celltype information to metadata\nmetadata(spe_cat)$cluster_codes <- data.frame(\n    celltype = factor(spe_cat$celltype)\n)\n\n### Pseudobulk-level MDS plot\n### MDS pseudobulk by cell type to highlight expression similarities between \n### cell types and subsequently for each celltype-sample-combination.\nCATALYST::pbMDS(\n    spe_cat,\n    by = \"cluster_id\",\n    features = rownames(spe_cat)[rowData(spe_cat)$marker_class == \"type\"],\n    label_by = \"cluster_id\",\n    k = \"celltype\"\n) +\n    scale_color_manual(values = metadata(spe_cat)$color_vectors$celltype)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-62-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### MDS pseudobulk by cell type and sample_id\n### We can see that the pseudobulk-expression profile of neutrophils seems \n### markedly distinct from the other cell types, while comparable cell types \n### such as the T cell subtypes group together. Furthermore, pseudobulk \n## cell-type profiles from SCCHN appear different from the other indications.\nCATALYST::pbMDS(\n    spe_cat, \n    by = \"both\", \n    features = rownames(spe_cat)[rowData(spe_cat)$marker_class == \"type\"], \n    k = \"celltype\", \n    shape_by = \"condition\", \n    size_by = TRUE\n) +\n  scale_color_manual(values = metadata(spe_cat)$color_vectors$celltype)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-62-2.png){width=672}\n:::\n\n```{.r .cell-code}\n### Reduced dimension plot on CLR of proportions\n### The output plots aim to illustrate the degree of similarity between \n### cell types based on sample proportions.\n### CLR on cluster proportions across samples\n### We can again observe that neutrophils have a divergent profile also in terms of their sample proportions.\nCATALYST::clrDR(\n    spe_cat, \n    dr = \"PCA\", \n    by = \"cluster_id\", \n    k = \"celltype\", \n    label_by = \"cluster_id\", \n    arrow_col = \"sample_id\", \n    point_pal = metadata(spe_cat)$color_vectors$celltype\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-62-3.png){width=672}\n:::\n\n```{.r .cell-code}\n### Pseudobulk expression boxplot\n### Notably, CD15 levels are elevated in SCCHN in comparison to all other \n### indications for most cell types.\nCATALYST::plotPbExprs(\n    spe_cat, \n    k = \"celltype\", \n    facet_by = \"cluster_id\", \n    ncol = 2, \n    features = rownames(spe_cat)[rowData(spe_cat)$marker_class == \"type\"]\n) +\n    scale_color_manual(values = metadata(spe_cat)$color_vectors$indication)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-62-4.png){width=672}\n:::\n:::\n\n\n### Sample level\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Dimensionality reduction visualization\n## UMAP colored by cell type and expression - dittoDimPlot\np1 <- dittoDimPlot(\n    spe,\n    var = \"sample_id\",\n    reduction.use = \"UMAP\",\n    size = 0.2,\n    colors = viridis(100),\n    do.label = FALSE\n) +\n    scale_color_manual(values = metadata(spe)$color_vectors$sample_id) +\n    theme(legend.title = element_blank()) +\n    ggtitle(\"Sample ID\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\np2 <- dittoDimPlot(\n    spe,\n    var = \"sample_id\",\n    reduction.use = \"UMAP_mnnCorrected\",\n    size = 0.2,\n    colors = viridis(100),\n    do.label = FALSE\n) +\n    scale_color_manual(values = metadata(spe)$color_vectors$sample_id) +\n    theme(legend.title = element_blank()) +\n    ggtitle(\"Sample ID\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\np3 <- dittoDimPlot(\n    spe,\n    var = \"patient_id\",\n    reduction.use = \"UMAP\",\n    size = 0.2,\n    do.label = FALSE\n) +\n    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +\n    theme(legend.title = element_blank()) +\n    ggtitle(\"Patient ID\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\np4 <- dittoDimPlot(\n    spe,\n    var = \"patient_id\",\n    reduction.use = \"UMAP_mnnCorrected\",\n    size = 0.2,\n    do.label = FALSE\n) +\n    scale_color_manual(values = metadata(spe)$color_vectors$patient_id) +\n    theme(legend.title = element_blank()) +\n    ggtitle(\"Patient ID\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for colour is already present.\nAdding another scale for colour, which will replace the existing scale.\n```\n:::\n\n```{.r .cell-code}\n### fastMNN approach (right side of the plot) leads to mixing of cells across \n### samples/patients and thus batch effect correction.\n(p1 + p2) / (p3 + p4)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-63-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Heatmap visualization to highlight biological differences across samples/patients.\ndittoHeatmap(\n    spe[,cur_cells], \n    genes = rownames(spe)[rowData(spe)$marker_class == \"type\"],\n    assay = \"exprs\", \n    order.by = c(\"patient_id\",\"sample_id\"),\n    cluster_cols = FALSE, \n    scale = \"none\",\n    heatmap.colors = viridis(100), \n    annot.by = c(\"celltype\", \"indication\", \"patient_id\", \"sample_id\"),\n    annotation_colors = list(\n        celltype = metadata(spe)$color_vectors$celltype,\n        indication = metadata(spe)$color_vectors$indication,\n        patient_id = metadata(spe)$color_vectors$patient_id,\n        sample_id = metadata(spe)$color_vectors$sample_id)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-64-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### mean expression by patient_id\npatient_mean <- aggregateAcrossCells(\n    as(spe, \"SingleCellExperiment\"),  \n    ids = spe$patient_id, \n    statistics = \"mean\",\n    use.assay.type = \"exprs\", \n    subset.row = rownames(spe)[rowData(spe)$marker_class == \"type\"]\n)\n\n### No scaling\ndittoHeatmap(\n    patient_mean,\n    assay = \"exprs\", \n    cluster_cols = TRUE, \n    scale = \"none\",\n    heatmap.colors = viridis(100),\n    annot.by = c(\"patient_id\",\"indication\",\"ncells\"),\n    annotation_colors = list(\n        patient_id = metadata(spe)$color_vectors$patient_id,\n        indication = metadata(spe)$color_vectors$indication,\n        ncells = plasma(100)\n    )\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-64-2.png){width=672}\n:::\n\n```{.r .cell-code}\n### Max expression scaling\ndittoHeatmap(\n    patient_mean,\n    assay = \"exprs\", \n    cluster_cols = TRUE, \n    scaled.to.max =  TRUE,\n    heatmap.colors.max.scaled = inferno(100),\n    annot.by = c(\"patient_id\",\"indication\",\"ncells\"),\n    annotation_colors = list(\n        patient_id = metadata(spe)$color_vectors$patient_id,\n        indication = metadata(spe)$color_vectors$indication,\n        ncells = plasma(100)\n    )\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-64-3.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Barplot visualization\ndittoBarPlot(\n    spe, \n    var = \"patient_id\", \n    group.by = \"celltype\"\n) +\n    scale_fill_manual(values = metadata(spe)$color_vectors$patient_id)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-65-1.png){width=672}\n:::\n\n```{.r .cell-code}\n### \ndittoBarPlot(\n    spe, \n    var = \"sample_id\", \n    group.by = \"celltype\"\n) +\n    scale_fill_manual(values = metadata(spe)$color_vectors$sample_id)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nScale for fill is already present.\nAdding another scale for fill, which will replace the existing scale.\n```\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-65-2.png){width=672}\n:::\n:::\n\n\n### ComplexHeatmap\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(22)\n\n### 1. Heatmap bodies ###\n### Heatmap body color\ncol_exprs <- colorRamp2(\n    c(0, 1, 2, 3, 4),\n    c(\"#440154FF\", \"#3B518BFF\", \"#20938CFF\", \"#6ACD5AFF\", \"#FDE725FF\")\n)\n\n### Create Heatmap objects\n### By cell type markers\ncelltype_mean <- aggregateAcrossCells(\n    as(spe, \"SingleCellExperiment\"),\n    ids = spe$celltype,\n    statistics = \"mean\",\n    use.assay.type = \"exprs\",\n    subset.row = rownames(spe)[rowData(spe)$marker_class == \"type\"]\n)\n\nh_type <- Heatmap(\n    t(assay(celltype_mean, \"exprs\")),\n    column_title = \"type_markers\",\n    col = col_exprs,\n    name = \"mean exprs\",\n    show_row_names = TRUE,\n    show_column_names = TRUE\n)\n\n# By cell state markers\ncellstate_mean <- aggregateAcrossCells(\n    as(spe, \"SingleCellExperiment\"),\n    ids = spe$celltype,\n    statistics = \"mean\",\n    use.assay.type = \"exprs\",\n    subset.row = rownames(spe)[rowData(spe)$marker_class == \"state\"]\n)\n\nh_state <- Heatmap(\n    t(assay(cellstate_mean, \"exprs\")),\n    column_title = \"state_markers\",\n    col = col_exprs,\n    name = \"mean exprs\",\n    show_row_names = TRUE,\n    show_column_names = TRUE\n)\n\n\n### 2. Heatmap annotation ###\n### 2.1  Metadata features\nanno <- colData(celltype_mean) |> \n    as.data.frame() |> \n    select(celltype, ncells)\n\n### Proportion of indication per celltype\nindication <- unclass(prop.table(table(spe$celltype, spe$indication), margin = 1))\n\n### Number of contributing patients per celltype\ncluster_PID <- colData(spe) |>\n    as.data.frame() |>\n    select(celltype, patient_id) |>\n    group_by(celltype) |> table() |>\n    as.data.frame()\n\nn_PID <- cluster_PID |>\n    filter(Freq > 0) |>\n    group_by(celltype) |>\n    dplyr::count(name = \"n_PID\") |>\n    column_to_rownames(\"celltype\")\n\n### Create HeatmapAnnotation objects\nha_anno <- HeatmapAnnotation(\n    celltype = anno$celltype,\n    border = TRUE,\n    gap = unit(1, \"mm\"),\n    col = list(celltype = metadata(spe)$color_vectors$celltype),\n    which = \"row\"\n)\n\nha_meta <- HeatmapAnnotation(\n    n_cells = anno_barplot(anno$ncells, width = unit(10, \"mm\")),\n    n_PID = anno_barplot(n_PID, width = unit(10, \"mm\")),\n    indication = anno_barplot(indication, width = unit(10, \"mm\"),\n    gp = gpar(fill = metadata(spe)$color_vectors$indication)),\n    border = TRUE,\n    annotation_name_rot = 90,\n    gap = unit(1, \"mm\"),\n    which = \"row\"\n)\n\n### 2.2 Spatial features\n### Add number of neighbors to spe object (saved in colPair)\nspe$n_neighbors <- countLnodeHits(colPair(spe, \"neighborhood\"))\n\n### Select spatial features and average over celltypes\nspatial <- colData(spe) |>\n    as.data.frame() |>\n    select(area, celltype, n_neighbors)\n\nspatial <- spatial |>\n    select(-celltype) |>\n    aggregate(by = list(celltype = spatial$celltype), FUN = mean) |>\n    column_to_rownames(\"celltype\")\n\n### Create HeatmapAnnotation object\nha_spatial <- HeatmapAnnotation(\n    area = spatial$area,\n    n_neighbors = spatial$n_neighbors,\n    border = TRUE,\n    gap = unit(1, \"mm\"),\n    which = \"row\"\n)\n\n### 3. Plot rich heatmap ###\n\n### Create HeatmapList object\nh_list <- h_type +\n    h_state +\n    ha_anno +\n    ha_spatial +\n    ha_meta\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: Heatmap/annotation names are duplicated: mean exprs\n\nWarning: Heatmap/annotation names are duplicated: mean exprs\n\nWarning: Heatmap/annotation names are duplicated: mean exprs\n\nWarning: Heatmap/annotation names are duplicated: mean exprs\n```\n:::\n\n```{.r .cell-code}\n### Add customized legend for anno_barplot()\nlgd <- Legend(\n    title = \"indication\",\n    at = colnames(indication),\n    legend_gp = gpar(fill = metadata(spe)$color_vectors$indication)\n)\n\n### Plot\ndraw(h_list, annotation_legend_list = list(lgd))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-66-1.png){width=672}\n:::\n:::\n\n\n## Reference\n\n- [Analysis workflow for IMC data](https://bodenmillergroup.github.io/IMCDataAnalysis/)\n- [Working with CellProfiler data in R](https://complexinterface.com/research/projects/image-analysis/)\n\n## Sessioninfo\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nR version 4.3.2 (2023-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Sonoma 14.4.1\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.11.0\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: Asia/Singapore\ntzcode source: internal\n\nattached base packages:\n[1] grid      stats4    stats     graphics  grDevices utils     datasets \n[8] methods   base     \n\nother attached packages:\n [1] gridExtra_2.3               ConsensusClusterPlus_1.66.0\n [3] kohonen_3.0.12              circlize_0.4.16            \n [5] ComplexHeatmap_2.18.0       lisaClust_1.10.1           \n [7] caret_6.0-94                lattice_0.22-6             \n [9] scran_1.30.2                bluster_1.12.0             \n[11] Rphenograph_0.99.1          igraph_2.0.3               \n[13] Seurat_5.0.3                SeuratObject_5.0.1         \n[15] sp_2.1-3                    BiocSingular_1.18.0        \n[17] harmony_1.2.0               Rcpp_1.0.12                \n[19] scater_1.30.1               scuttle_1.12.0             \n[21] batchelor_1.18.1            mclust_6.1                 \n[23] tiff_0.1-12                 BiocParallel_1.36.0        \n[25] pheatmap_1.0.12             CATALYST_1.26.1            \n[27] dittoSeq_1.14.3             cytomapper_1.14.0          \n[29] EBImage_4.44.0              imcRtools_1.8.0            \n[31] SpatialExperiment_1.12.0    SingleCellExperiment_1.24.0\n[33] SummarizedExperiment_1.32.0 Biobase_2.62.0             \n[35] GenomicRanges_1.54.1        GenomeInfoDb_1.38.8        \n[37] IRanges_2.36.0              S4Vectors_0.40.2           \n[39] BiocGenerics_0.48.1         MatrixGenerics_1.14.0      \n[41] matrixStats_1.3.0           viridis_0.6.5              \n[43] viridisLite_0.4.2           RColorBrewer_1.1-3         \n[45] cowplot_1.1.3               patchwork_1.2.0            \n[47] ggridges_0.5.6              ggrepel_0.9.5              \n[49] lubridate_1.9.3             forcats_1.0.0              \n[51] stringr_1.5.1               dplyr_1.1.4                \n[53] purrr_1.0.2                 readr_2.1.5                \n[55] tidyr_1.3.1                 tibble_3.2.1               \n[57] ggplot2_3.5.1               tidyverse_2.0.0            \n[59] qs_0.26.1                   fs_1.6.4                   \n[61] here_1.0.1                 \n\nloaded via a namespace (and not attached):\n  [1] vroom_1.6.5                 nnet_7.3-19                \n  [3] goftest_1.2-3               DT_0.33                    \n  [5] HDF5Array_1.30.1            TH.data_1.1-2              \n  [7] vctrs_0.6.5                 spatstat.random_3.2-3      \n  [9] RApiSerialize_0.1.2         digest_0.6.35              \n [11] png_0.1-8                   shape_1.4.6.1              \n [13] proxy_0.4-27                spicyR_1.14.3              \n [15] deldir_2.0-4                parallelly_1.37.1          \n [17] magick_2.8.3                MASS_7.3-60.0.1            \n [19] reshape2_1.4.4              httpuv_1.6.15              \n [21] foreach_1.5.2               withr_3.0.0                \n [23] xfun_0.43                   ggpubr_0.6.0               \n [25] survival_3.5-8              memoise_2.0.1              \n [27] RTriangle_1.6-0.13          ggbeeswarm_0.7.2           \n [29] RProtoBufLib_2.14.1         drc_3.0-1                  \n [31] systemfonts_1.0.6           zoo_1.8-12                 \n [33] GlobalOptions_0.1.2         gtools_3.9.5               \n [35] pbapply_1.7-2               promises_1.3.0             \n [37] httr_1.4.7                  rstatix_0.7.2              \n [39] globals_0.16.3              fitdistrplus_1.1-11        \n [41] rhdf5filters_1.14.1         stringfish_0.16.0          \n [43] rhdf5_2.46.1                archive_1.1.7              \n [45] units_0.8-5                 miniUI_0.1.1.1             \n [47] generics_0.1.3              concaveman_1.1.0           \n [49] zlibbioc_1.48.2             ScaledMatrix_1.10.0        \n [51] ggraph_2.2.1                randomForest_4.7-1.1       \n [53] polyclip_1.10-6             GenomeInfoDbData_1.2.11    \n [55] SparseArray_1.2.4           fftwtools_0.9-11           \n [57] xtable_1.8-4                doParallel_1.0.17          \n [59] evaluate_0.23               S4Arrays_1.2.1             \n [61] hms_1.1.3                   irlba_2.3.5.1              \n [63] colorspace_2.1-0            ROCR_1.0-11                \n [65] reticulate_1.36.0           spatstat.data_3.0-4        \n [67] magrittr_2.0.3              lmtest_0.9-40              \n [69] later_1.3.2                 spatstat.geom_3.2-9        \n [71] future.apply_1.11.2         scattermore_1.2            \n [73] XML_3.99-0.16.1             RcppAnnoy_0.0.22           \n [75] class_7.3-22                svgPanZoom_0.3.4           \n [77] pillar_1.9.0                nlme_3.1-164               \n [79] iterators_1.0.14            compiler_4.3.2             \n [81] beachmat_2.18.1             RSpectra_0.16-1            \n [83] stringi_1.8.4               gower_1.0.1                \n [85] sf_1.0-16                   minqa_1.2.6                \n [87] ClassifyR_3.6.5             tensor_1.5                 \n [89] plyr_1.8.9                  crayon_1.5.2               \n [91] abind_1.4-5                 locfit_1.5-9.9             \n [93] graphlayouts_1.1.1          bit_4.0.5                  \n [95] terra_1.7-71                sandwich_3.1-0             \n [97] codetools_0.2-20            multcomp_1.4-25            \n [99] recipes_1.0.10              e1071_1.7-14               \n[101] GetoptLong_1.0.5            plotly_4.10.4              \n[103] MultiAssayExperiment_1.28.0 mime_0.12                  \n[105] splines_4.3.2               fastDummies_1.7.3          \n[107] sparseMatrixStats_1.14.0    knitr_1.45                 \n[109] utf8_1.2.4                  clue_0.3-65                \n[111] lme4_1.1-35.3               listenv_0.9.1              \n[113] nnls_1.5                    DelayedMatrixStats_1.24.0  \n[115] ggsignif_0.6.4              scam_1.2-16                \n[117] Matrix_1.6-5                statmod_1.5.0              \n[119] tzdb_0.4.0                  svglite_2.1.3              \n[121] tweenr_2.0.3                pkgconfig_2.0.3            \n[123] tools_4.3.2                 cachem_1.0.8               \n[125] RhpcBLASctl_0.23-42         numDeriv_2016.8-1.1        \n[127] DBI_1.2.2                   fastmap_1.1.1              \n[129] rmarkdown_2.26              scales_1.3.0               \n[131] ica_1.0-3                   shinydashboard_0.7.2       \n[133] broom_1.0.5                 dotCall64_1.1-1            \n[135] carData_3.0-5               rpart_4.1.23               \n[137] RANN_2.6.1                  farver_2.1.1               \n[139] mgcv_1.9-1                  tidygraph_1.3.1            \n[141] yaml_2.3.8                  cli_3.6.2                  \n[143] leiden_0.4.3.1              lifecycle_1.0.4            \n[145] uwot_0.1.16                 mvtnorm_1.2-4              \n[147] lava_1.8.0                  backports_1.4.1            \n[149] cytolib_2.14.1              timechange_0.3.0           \n[151] gtable_0.3.5                rjson_0.2.21               \n[153] progressr_0.14.0            pROC_1.18.5                \n[155] limma_3.58.1                parallel_4.3.2             \n[157] edgeR_4.0.16                jsonlite_1.8.8             \n[159] RcppHNSW_0.6.0              bitops_1.0-7               \n[161] bit64_4.0.5                 Rtsne_0.17                 \n[163] FlowSOM_2.10.0              spatstat.utils_3.0-4       \n[165] BiocNeighbors_1.20.2        RcppParallel_5.1.7         \n[167] flowCore_2.14.2             metapod_1.10.1             \n[169] dqrng_0.3.2                 timeDate_4032.109          \n[171] lazyeval_0.2.2              shiny_1.8.1.1              \n[173] htmltools_0.5.8.1           sctransform_0.4.1          \n[175] distances_0.1.10            glue_1.7.0                 \n[177] spam_2.10-0                 ResidualMatrix_1.12.0      \n[179] XVector_0.42.0              RCurl_1.98-1.14            \n[181] rprojroot_2.0.4             classInt_0.4-10            \n[183] jpeg_0.1-10                 boot_1.3-30                \n[185] R6_2.5.1                    labeling_0.4.3             \n[187] cluster_2.1.6               Rhdf5lib_1.24.2            \n[189] ipred_0.9-14                nloptr_2.0.3               \n[191] DelayedArray_0.28.0         tidyselect_1.2.1           \n[193] vipor_0.4.7                 plotrix_3.8-4              \n[195] ggforce_0.4.2               raster_3.6-26              \n[197] car_3.1-2                   future_1.33.2              \n[199] ModelMetrics_1.2.2.2        rsvd_1.0.5                 \n[201] munsell_0.5.1               KernSmooth_2.23-22         \n[203] data.table_1.15.4           htmlwidgets_1.6.4          \n[205] rlang_1.1.3                 spatstat.sparse_3.0-3      \n[207] spatstat.explore_3.2-7      lmerTest_3.1-3             \n[209] colorRamps_2.3.4            Cairo_1.6-2                \n[211] ggnewscale_0.4.10           fansi_1.0.6                \n[213] hardhat_1.3.1               prodlim_2023.08.28         \n[215] beeswarm_0.4.0             \n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}