{
  "hash": "b21804566275612d54d8fcad8a2c52a3",
  "result": {
    "markdown": "---\ntitle: \"Normalization example for SomaLogic proteomic data\"\ndate: 2024-05-08\ndate-modified: last-modified\ncategories:\n  - proteomic\n  - normalization\nimage: somalogic.jpg\ndescription: Raw SomaScan Assay data may contain systematic biases from many sources, such as variation introduced by the readout, pipetting errors, inherent sample variation, or consumable reagent changes. Standardization is an important  tool for removing nuisance variance\n---\n\n\n\n\n## Intial setup\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(here)\n## here() starts at /Users/zhonggr/Library/CloudStorage/OneDrive-Personal/quarto\nlibrary(fs)\nlibrary(tidyverse)\n## ── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n## ✔ dplyr     1.1.4     ✔ readr     2.1.5\n## ✔ forcats   1.0.0     ✔ stringr   1.5.1\n## ✔ ggplot2   3.5.1     ✔ tibble    3.2.1\n## ✔ lubridate 1.9.3     ✔ tidyr     1.3.1\n## ✔ purrr     1.0.2\n## ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n## ✖ dplyr::filter() masks stats::filter()\n## ✖ dplyr::lag()    masks stats::lag()\n## ℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n\n### Project dir\ndir  <-  \"projects/2024_Plasma7k_SomaScan\"\n```\n:::\n\n\n## Step0: Load data\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### Normalization methods\nnorm <- c(\n    \"raw\", \"hyb\", \"hyb.msnCal\", \"hyb.msnCal.ps\", \"hyb.msnCal.ps.cal\", \n    \"hyb.msnCal.ps.cal.msnAll\"\n    )\nn_norm <- length(norm)\n\n### Container to save normalized data\nRFU <- vector(\"list\", n_norm)\n\n### Load sample meta as matrix\nsamples <- read.table(\n    here(dir, \"data/sample.txt\"), header = T, quote = \"\", \n    comment.char = \"\", sep = \"\\t\"\n) |>\n    as.matrix()\n\n### 1806 human plasma samples,  2050 sample and controls across 22 plates\ndim(samples)\n## [1] 2050   32\nsamples[1:5, 1:5]\n##      PlateId    PlateRunDate ScannerID    PlatePosition SlideId       \n## [1,] \"P0031168\" \"2021-12-03\" \"SG12344217\" \"A1\"          \"258633829464\"\n## [2,] \"P0031168\" \"2021-12-03\" \"SG12344217\" \"A10\"         \"258633829473\"\n## [3,] \"P0031168\" \"2021-12-03\" \"SG12344217\" \"A11\"         \"258633829518\"\n## [4,] \"P0031168\" \"2021-12-03\" \"SG12344217\" \"A12\"         \"258633829519\"\n## [5,] \"P0031168\" \"2021-12-03\" \"SG12344217\" \"A2\"          \"258633829465\"\nn_sample <- nrow(samples)\nplates <- unique(samples[, \"PlateId\"])\nn_plate <- length(plates)\n\n### Load feature meta\nsomamers <- read.table(\n    here(dir, \"data/somamer.txt\"), header = T, quote = \"\", \n    comment.char = \"\", sep = \"\\t\"\n) |>\n    as.matrix()\n\n### Total 7596 SOMAmers (feature); 7288 human protein, others are control\ndim(somamers)\n## [1] 7596   13\nsomamers[1:5, 1:13]\n##      SeqId      SeqIdVersion SomaId     Target  UniProt  EntrezGeneID\n## [1,] \"10000-28\" \" 3\"         \"SL019233\" \"CRBB2\" \"P43320\" \"1415\"      \n## [2,] \"10001-7\"  \" 3\"         \"SL002564\" \"c-Raf\" \"P04049\" \"5894\"      \n## [3,] \"10003-15\" \" 3\"         \"SL019245\" \"ZNF41\" \"P51814\" \"7592\"      \n## [4,] \"10006-25\" \" 3\"         \"SL019228\" \"ELK1\"  \"P19419\" \"2002\"      \n## [5,] \"10008-43\" \" 3\"         \"SL019234\" \"GUC1A\" \"P43080\" \"2978\"      \n##      EntrezGeneSymbol Organism Units Type      Dilution\n## [1,] \"CRYBB2\"         \"Human\"  \"RFU\" \"Protein\" \"2e+01\" \n## [2,] \"RAF1\"           \"Human\"  \"RFU\" \"Protein\" \"2e+01\" \n## [3,] \"ZNF41\"          \"Human\"  \"RFU\" \"Protein\" \"5e-01\" \n## [4,] \"ELK1\"           \"Human\"  \"RFU\" \"Protein\" \"2e+01\" \n## [5,] \"GUCA1A\"         \"Human\"  \"RFU\" \"Protein\" \"2e+01\" \n##      Cal_Interplate_Ref_Pass1 Cal_Interplate_Ref_Pass2\n## [1,] \"8.879371e+02\"           \"8.942875e+02\"          \n## [2,] \"3.963486e+02\"           \"3.980628e+02\"          \n## [3,] \"2.260907e+02\"           \"2.241294e+02\"          \n## [4,] \"8.352066e+02\"           \"8.344351e+02\"          \n## [5,] \"7.299779e+02\"           \"7.297289e+02\"\nn_somamer <- nrow(somamers)\n\n### Load SomaScan raw assay data matrix (2050 x 7596)\nRFU[[1]] <- read.table(here(dir, \"data/RFU_raw.txt\"), header = F, sep = \"\\t\") |> \n    as.matrix()\n\n### 2050x7596\ndim(RFU[[1]])\n## [1] 2050 7596\nRFU[[1]][1:5, 1:5]\n##         V1    V2    V3    V4     V5\n## [1,] 748.8 325.4 217.1 572.0  720.7\n## [2,] 577.5 385.4 325.7 634.8  731.0\n## [3,] 526.8 318.6 203.0 581.3  618.0\n## [4,] 508.4 422.7 213.1 641.2  688.2\n## [5,] 450.5 290.5 202.2 580.2 2294.6\n\n### Dilution groups\ndilution <- c(0.005, 0.5, 20)\ndilution_lab <- c(\"0_005\", \"0_5\", \"20\")\nn_dilution <- length(dilution)\n```\n:::\n\n\n## Step1: Hybridization control normalization\n\nHybridization control normalization is designed to adjust for nui- sance variance on the basis of individual wells. Each well contains nHCE = 12 HCE (Hybridization Control Elu‑ tion) SOMAmers at different concentrations spanning more than 3 orders of magnitude. By comparing each observed HCE probe to its corresponding reference value, and then calculating the median over all HCE probes, we obtain the scale factor for the i-th well, i.e.\n\nNotice that this normalization step is performed independently for each well; once the scale factor is determined, all SOMAmer RFUs in the well are multiplied by the same scale factor.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### well = sample\n### Get idx for Hybridization feature \nsomamer_HCE <- somamers[, \"Type\"] == \"Hybridization Control Elution\"\ntable(somamer_HCE)\n## somamer_HCE\n## FALSE  TRUE \n##  7584    12\n\n### 12 control SOMAmer reagents addded to the eluate just prior to readout\nn_HCE <- sum(somamer_HCE)\n\n### Get hybridization control data: 1) Subset only the HYBs for all samples\nRFU_HCE <- RFU[[1]][, somamer_HCE]\n\n### Use another container to save hybridization normalized data\nRFU[[2]] <- RFU[[1]]\n\n### Empty container to save scale factor for hyb \nhyb_scale_factor <- rep(NA, n_sample)\n\n### Empty container to save ratio\nHCE_ratio <- matrix(rep(NA, n_sample * n_HCE), ncol = n_HCE)\n\n### Loop through plates\nfor (i_plate in 1:n_plate) {\n\n    ### Get current sample index from current plate\n    sample_idx <- samples[, \"PlateId\"] == plates[i_plate]\n\n    ### Get current sample data from current plate\n    RFU_plate <- RFU[[2]][sample_idx, ]\n\n    ### Current plate ratio\n    HCE_ratio_plate <- HCE_ratio[sample_idx, ]\n\n    ### Current plate hyb scale factor\n    hyb_scale_factor_plate <- hyb_scale_factor[sample_idx]\n\n    ### Calculate the median of each HYB for calibrators\n    hyb_intra_ref <- apply(RFU_HCE[sample_idx, ], 2, median)\n    \n    ### Loop through sample within the plate for HCE\n    for (i_sample in 1:sum(sample_idx)) {\n        \n        ### Calculate the ratio\n        HCE_ratio_plate[i_sample, ] <- hyb_intra_ref / RFU_plate[i_sample, somamer_HCE]\n        \n        ### Use the median of HCE somamers as scale factor for each sample\n        hyb_scale_factor_plate[i_sample] <- median(HCE_ratio_plate[i_sample, ])\n       \n        ### Apply the same scale factor for all features by each sample\n        RFU_plate[i_sample, ] <- hyb_scale_factor_plate[i_sample] * RFU_plate[i_sample, ]\n    }\n\n    HCE_ratio[sample_idx, ] <- HCE_ratio_plate\n    hyb_scale_factor[sample_idx] <- hyb_scale_factor_plate\n    RFU[[2]][sample_idx, ] <- RFU_plate\n}\n\nHCE_ratio[1:5, 1:12]\n##           [,1]      [,2]      [,3]     [,4]      [,5]      [,6]      [,7]\n## [1,] 0.9028951 0.8465086 0.8636644 0.840359 0.8238109 0.8347273 0.8409453\n## [2,] 1.0688565 1.0757213 1.0718344 1.074034 1.0761508 1.0865276 1.0898142\n## [3,] 1.1755157 1.0443237 1.0618485 1.027817 1.0278632 1.0458846 1.0242561\n## [4,] 1.2409731 1.0985134 1.1283522 1.093489 1.0620677 1.0887500 1.0404074\n## [5,] 0.9606874 0.8826018 0.8870467 0.870571 0.8706513 0.8889404 0.8772853\n##           [,8]      [,9]     [,10]     [,11]     [,12]\n## [1,] 0.8245079 0.8392952 0.8265836 0.8554753 0.8322683\n## [2,] 1.0839455 1.1161029 1.0670241 1.0616821 1.1057077\n## [3,] 1.0360929 1.0523256 1.0140127 1.0951655 1.0508598\n## [4,] 1.0976469 1.0806892 1.0949106 1.1302752 1.1075787\n## [5,] 0.8698039 0.8517074 0.8504274 0.9175154 0.8744776\n```\n:::\n\n\n## Step2: Median signal normalization on calibrators\n\nMedian signal normalization is an intra-plate normalization procedure performed within wells of the same sample class (i.e. separately for buffer, QC, calibrator, and experimental samples) and within SOMAmers of the same dilution grouping (i.e. 20%, 0.5%, and 0.005%). \n\nIt is intended to remove sample-to-sample differences in total RFU brightness that may be due to differences in overall protein concentration, pipetting variation, variation in reagent concentrations, assay timing, and other sources of variability within a group of otherwise comparable samples. Since RFU brightness differs significantly across SOMAmers, median signal normalization proceeds in two steps. \n\n- First, the median RFU of each SOMAmer is determined (across all samples of the same sample type) and sample RFUs are divided by it. The ratio corresponding to the i-th sample and α-th SOMAmer is thus given by\nPerforming median signal normalization on experimental samples before inter-plate calibration presents the risk of enhancing plate-to-plate differences. \nThus, in this step, we restrict median signal normalization to calibrators only.\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nRFU[[3]] = RFU[[2]]\nSF_medNormInt <- matrix(rep(1, n_sample * n_dilution), ncol = n_dilution)\n\n### Only do the normalization on calibrator samples\nsample_type  <- c(\"Calibrator\")\n\n### Loop throuh plate\nfor (i_plate in 1:length(plates)) {\n    \n    sel1  <-  samples[, \"PlateId\"] == plates[i_plate]\n    \n    ### Loop through sample type\n    for (i_sample_type in 1:length(sample_type)) {\n        \n        ### Get the Calibrator sample idx\n        sel2  <-  samples[, \"SampleType\"] == sample_type[i_sample_type]\n        \n        sample_idx  <-  which(sel1 & sel2)\n        \n        ### Loop through dilution\n        for (i_dilution in 1:n_dilution) {\n            \n            sel_somamer <- as.numeric(somamers[, \"Dilution\"]) == dilution[i_dilution]\n            \n            dat  <-  RFU[[3]][sample_idx, sel_somamer, drop = F]\n            \n            dat2 <- dat\n            \n            ### Loop throuhg dilution somamers\n            for (i in 1:ncol(dat2)) {\n\n                ### Get the median of dilution somamer  \n                dat2[, i]  <-  dat2[, i] / median(dat2[, i])\n            }\n\n            for (i in 1:nrow(dat)) {\n                \n                SF_medNormInt[sample_idx[i], i_dilution] = 1 / median(dat2[i, ])\n                \n                dat[i, ] = dat[i, ] * SF_medNormInt[sample_idx[i], i_dilution]\n            }\n\n            RFU[[3]][sample_idx, sel_somamer]  <-  dat\n        }\n    }\n}\n\nRFU[[3]][1:5, 1:10]\n##            V1       V2       V3       V4        V5       V6       V7       V8\n## [1,] 628.8625 273.2797 182.3265 480.3811  605.2634 300.3222 1951.674 1160.725\n## [2,] 621.3531 414.6658 350.4324 683.0042  786.5093 445.3299 3063.620 2156.176\n## [3,] 550.5609 332.9702 212.1561 607.5190  645.8744 331.9251 2623.734 1432.524\n## [4,] 557.3481 463.3970 233.6170 702.9339  754.4590 373.1733 2593.796 1444.457\n## [5,] 394.5846 254.4436 177.1032 508.1864 2009.7976 243.4075 1846.358 1060.342\n##            V9       V10\n## [1,] 354.1551  721.9994\n## [2,] 521.5062 1008.0445\n## [3,] 431.5235  832.8435\n## [4,] 431.6050  932.3851\n## [5,] 312.3393  608.3873\n```\n:::\n\n## Step3: Plate-scale normalization\n\nPlate-scale normalization aims to control for variance in total signal intensity from plate to plate. \nNo protein spikes are added to the calibrator; the procedure solely relies on the endogenous levels of each protein within the set of calibrator replicates\n\nWe utilize an internal reference determined by the median across all calibrators on all plates, i.e.\n\n$$\n\\begin{aligned} RFU_{\\alpha }^{Cal,ref}\\equiv \\text {median}\\left\\{ RFU_{i\\alpha }^{Cal,obs} \\right\\} _{i=1,\\ldots ,n_{Cal}}^{p=1,\\ldots ,n_p}\\ . \\end{aligned}\n$$\n\nFor the - SOMAmer on the p- plate,\n$$\n\\begin{aligned} SF_\\alpha ^p = RFU_\\alpha ^{Cal,ref}/\\text {median}\\left\\{ RFU_{i\\alpha }^{Cal,obs} \\right\\} _{i=1,\\ldots ,n_{Cal}}^p\\ . \\end{aligned}\n$$\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nRFU[[4]] = RFU[[3]]\n\nSF <- matrix(rep(NA, n_plate * n_somamer), ncol = n_somamer)\n\n### Get calibrator sample idx\nsel_cal <- samples[, \"SampleType\"] == \"Calibrator\"\n\ncal_interplate_ref <- rep(NA, n_somamer)\n\n### Loop through features\nfor (i_somamer in 1:n_somamer) {\n    ### Get the median of control\n    cal_interplate_ref[i_somamer]  <-  median(RFU[[4]][sel_cal, i_somamer])\n\n    for (i_plate in 1:n_plate) {\n\n        sel_plate = samples[, \"PlateId\"] == plates[i_plate]\n        \n        cal_intraplate_ref = median(RFU[[4]][sel_cal & sel_plate, i_somamer])\n\n        SF[i_plate, i_somamer] = cal_interplate_ref[i_somamer] / cal_intraplate_ref\n    }\n}\n\nSF_plateScale  <-  apply(SF, 1, median)\n\nfor (i_plate in 1:n_plate) {\n\n    sel_plate = samples[, \"PlateId\"] == plates[i_plate]\n\n    RFU[[4]][sel_plate, ] = RFU[[4]][sel_plate, ] * SF_plateScale[i_plate]\n}\n```\n:::\n\n\nn order to correct the overall brightness level of the p- plate, we calculate the plate-scale scale factor as the median of across all SOMAmers, i.e.\n\n## Step4: Inter-plate calibration\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nRFU[[5]] <- RFU[[4]]\n\nSF_cal <- matrix(rep(NA, n_plate * n_somamer), ncol = n_somamer)\nsel_cal <- samples[, \"SampleType\"] == \"Calibrator\"\n\n### New interplate reference\ncal_interplate_ref_N = rep(NA, n_somamer)\n\nfor (i_somamer in 1:n_somamer) {\n    \n    cal_interplate_ref_N[i_somamer] <- median(RFU[[5]][sel_cal, i_somamer])\n    \n    for (i_plate in 1:n_plate) {\n    \n        sel_plate <- samples[, \"PlateId\"] == plates[i_plate]\n    \n        cal_intraplate_ref <- median(RFU[[5]][sel_cal & sel_plate, i_somamer])\n\n        SF_cal[i_plate, i_somamer] <- cal_interplate_ref_N[i_somamer] / cal_intraplate_ref\n        \n        RFU[[5]][sel_plate, i_somamer] <- RFU[[5]][sel_plate, i_somamer] * SF_cal[i_plate, i_somamer]\n    }\n}\n```\n:::\n\n\n## Step6: Median signal normalization on all sample types\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nRFU[[6]] <- RFU[[5]]\n\nSF_medNormFull  <- matrix(rep(1, n_sample * n_dilution), ncol = n_dilution)\n\nsample_type <- c(\"QC\", \"Sample\", \"Buffer\", \"Calibrator\")\nn_sampl_type = length(sample_type)\n\nfor (i_sample_type in 1:length(sample_type)) {\n    \n    sample_idx <- which(samples[, \"SampleType\"] == sample_type[i_sample_type])\n    \n    for (i_dilution in 1:n_dilution) {\n\n        sel_somamer <- as.numeric(somamers[, \"Dilution\"]) == dilution[i_dilution]\n        \n        dat <- RFU[[6]][sample_idx, sel_somamer, drop = F]\n        \n        dat2 <- dat\n        \n        for (i in 1:ncol(dat2)) {\n            \n            dat2[, i] <- dat2[, i] / median(dat2[, i])\n        }\n\n        for (i in 1:nrow(dat)) {\n        \n            SF_medNormFull[sample_idx[i], i_dilution] <- 1 / median(dat2[i, ])\n        \n            dat[i, ] = dat[i, ] * SF_medNormFull[sample_idx[i], i_dilution]\n        }\n\n        RFU[[6]][sample_idx, sel_somamer]  <-  dat\n    }\n}\n```\n:::\n\n\n## Save results\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\n### Save normalized results\ndir_create(here(dir, \"results\"))\nfor (i_norm in 2:n_norm) {\n    outfile <- path(here(dir, \"results\", paste0(\"RFU_\", norm[i_norm], \".txt\")))\n    write(t(RFU[[i_norm]]), ncol = n_somamer, file = outfile, sep = \"\\t\")\n}\n\n### Save sample scale factors\noutfile <- path(here(dir, \"results\", \"samples_SF.txt\"))\nheader <- c(\n    colnames(samples), \"hyb_scale_factor\", paste0(\"SF_msnCal_d\", dilution_lab), \n    paste0(\"SF_msnAll_d\", dilution_lab)\n)\noutput <- rbind(header, cbind(samples, hyb_scale_factor, SF_medNormInt, SF_medNormFull))\nwrite(t(output), ncol = ncol(output), file = outfile, sep = \"\\t\")\n\n### Save feature scale factor\noutfile <- path(here(dir, \"results\", \"somamers_SF.txt\"))\nheader <- c(\n    colnames(somamers), \"Cal_Interplate_Ref_Pass1\", \"Cal_Interplate_Ref_Pass2\"\n)\noutput <- rbind(\n    header, \n    cbind(somamers, cal_interplate_ref, cal_interplate_ref_N)\n)\nwrite(t(output), ncol = ncol(output), file = outfile, sep = \"\\t\")\n\n### Save plate scale factor\noutfile <- path(here(dir, \"results\", \"plates_SF.txt\"))\nheader <- c(\"Plate\", \"SF_plateScale\", paste0(\"SF_cal_\", somamers[, \"SeqId\"]))\noutput <- rbind(header, cbind(plate, SF_plateScale, SF_cal))\nwrite(t(output), ncol = ncol(output), file = outfile, sep = \"\\t\")\n```\n:::\n\n\n## Reference\n\n- [Assessment of Variability in the Plasma 7k SomaScan Proteomics Assay](https://osf.io/srgef/)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}