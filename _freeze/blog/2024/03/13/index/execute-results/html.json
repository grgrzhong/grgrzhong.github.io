{
  "hash": "ca75ad13f0584137f1ccb0298a154758",
  "result": {
    "markdown": "---\ntitle: \"SingleCellExperiment | Practise Single-cell RNA-seq data analysis\"\ndate: 2024-03-13\ndate-modified: last-modified\ncategories:\n  - scrna\nimage: workflow.png\n# description: All the learning materials are from credited or adapted from Harvard Chan Bioinformatics Core. \nexecute: \n  freeze: true\n  eval: false\n---\n\n\n::: {.callout-note}\nAll the contents are credited or adapted from [Orchestrating Single-Cell Analysis with Bioconductor](https://bioconductor.org/books/release/OSCA/) for leaning purpose.\n:::\n\n\n\n\n\n## Overall Workflow\n\n[](workflow.png)\n\n## Install and Load packages\n\n::: {.cell}\n\n```{.r .cell-code}\n# BiocManager::install(\"OSCA.intro\")\n# BiocManager::install(\"SingleCellExperiment\", force = TRUE)\n# BiocManager::install(c(\"scuttle\", \"scran\", \"scater\", \"uwot\", \"rtracklayer\"))\n\nlibrary(scRNAseq)\nlibrary(scuttle)\nlibrary(scater)\nlibrary(robustbase)\nlibrary(org.Mm.eg.db)\n```\n:::\n\n\n## Read counts into R\n\n### From tabular formats\n### From Cellranger output\n### From HDF5-based formats\n\n## SingleCellExperiment class\n\n## Quality Control\n\n### QC metrics\n\nCommon QC metrics to identify low-quality cells based on their expression profiles.\n\n- library size\n- number of expressed features\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#--- loading ---#\nsce.416b <- LunSpikeInData(which=\"416b\")\nsce.416b$block <- factor(sce.416b$block)\n\n# 46604 features x  192 cells\nsce.416b\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identifying the mitochondrial transcripts in our SingleCellExperiment.\nlocation <- rowRanges(sce.416b)\nis.mito <- any(seqnames(location) == \"MT\")\n\ndf <- scater::perCellQCMetrics(sce.416b, subsets = list(Mito = is.mito))\n# Total count for each cell\nsummary(df$sum)\n\n# The number of detected genes\nsummary(df$detected)\n\n# The percentage of reads mapped to mitochondrial transcripts\nsummary(df$subsets_Mito_percent)\n\n# The percentage of reads mapped to ERCC transcripts\nsummary(df$altexps_ERCC_percent)\n\n# Computes and appends the per-cell QC statistics to the colData\nsce.416b <- addPerCellQCMetrics(sce.416b, subsets=list(Mito=is.mito))\ncolnames(colData(sce.416b))\n```\n:::\n\n\nA key assumption here is that the QC metrics are independent of the biological state of each cell. Poor values (e.g., low library sizes, high mitochondrial proportions) are presumed to be driven by technical factors rather than biological processes, meaning that the subsequent removal of cells will not misrepresent the biology in downstream analyses. \n\nMajor violations of this assumption would potentially result in the loss of cell types that have, say, systematically low RNA content or high numbers of mitochondria.\n\n### Identifying low-quality cells\n\n#### With fixed thresholds\nThe simplest approach to identifying low-quality cells involves applying **fixed thresholds** to the QC metrics. \n\nFor example, we might consider cells to be low quality if they:\n\n- have library sizes below 100,000 reads; \n- express fewer than 5,000 genes; \n- have spike-in proportions above 10%; \n- or have mitochondrial proportions above 10%.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# With fixed thresholds\nqc.lib <- df$sum < 1e5\nqc.nexprs <- df$detected < 5e3\nqc.spike <- df$altexps_ERCC_percent > 10\nqc.mito <- df$subsets_Mito_percent > 10\ndiscard <- qc.lib | qc.nexprs | qc.spike | qc.mito\n\n# Summarize the number of cells removed for each reason.\nDataFrame(\n    LibSize = sum(qc.lib), NExprs = sum(qc.nexprs),\n    SpikeProp = sum(qc.spike), MitoProp = sum(qc.mito), Total = sum(discard)\n)\n```\n:::\n\n::: {.callout-note}\nWhile simple, this strategy requires considerable experience to determine appropriate thresholds for each experimental protocol and biological system. \n- Thresholds for read count-based data are not applicable for UMI-based data, and vice versa. \n- Differences in mitochondrial activity or total RNA content require constant adjustment of the mitochondrial and spike-in thresholds, respectively, for different biological systems. \n- Indeed, even with the same protocol and system, the appropriate threshold can vary from run to run due to the vagaries of cDNA capture efficiency and sequencing depth per cell.\n:::\n\n\n#### With adaptive thresholds\nWe then identify cells that are outliers for the various QC metrics, based on the median absolute deviation (MAD) from the median value of each metric across all cells. \n\nBy default, we consider a value to be an outlier if it is more than 3 MADs from the median in the “problematic” direction. This is loosely motivated by the fact that such a filter will retain 99% of non-outlier values that follow a normal distribution.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Identify cells with log-transformed library sizes that are more than 3 MADs below the median\nreasons <- perCellQCFilters(\n    df,\n    sub.fields = c(\"subsets_Mito_percent\", \"altexps_ERCC_percent\")\n)\ncolSums(as.matrix(reasons))\n\n# A cell that is an outlier for any of these metrics is considered to be of low quality and discarded\nsummary(reasons$discard)\n\n# Exact filter thresholds from the attributes of each of the logical vectors\nattr(reasons$low_lib_size, \"thresholds\")\nattr(reasons$low_n_features, \"thresholds\")\n```\n:::\n\n\n#### Other approaches\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstats <- cbind(\n    log10(df$sum), log10(df$detected),\n    df$subsets_Mito_percent, df$altexps_ERCC_percent\n)\n\noutlying <- adjOutlyingness(stats, only.outlyingness = TRUE)\nmulti.outlier <- isOutlier(outlying, type = \"higher\")\nsummary(multi.outlier)\n```\n:::\n\n\nOutliers can also be identified from the gene expression profiles, rather than QC metrics. \n\nWe consider this to be a risky strategy as it can remove **high-quality cells in rare populations**.\n\n#### Diagnostic plots\n\n::: {.cell}\n\n```{.r .cell-code}\ncolData(sce.416b) <- cbind(colData(sce.416b), df)\nsce.416b$block <- factor(sce.416b$block)\nsce.416b$phenotype <- ifelse(\n    grepl(\"induced\", sce.416b$phenotype),\n    \"induced\", \"wild type\"\n)\nsce.416b$discard <- reasons$discard\n\ngridExtra::grid.arrange(\n    plotColData(\n        sce.416b, x = \"block\", y = \"sum\", colour_by = \"discard\",\n        other_fields = \"phenotype\"\n    ) +\n        facet_wrap(~phenotype) +\n        scale_y_log10() + ggtitle(\"Total count\"),\n\n    plotColData(\n        sce.416b, x = \"block\", y = \"detected\", colour_by = \"discard\",\n        other_fields = \"phenotype\"\n    ) +\n        facet_wrap(~phenotype) +\n        scale_y_log10() + ggtitle(\"Detected features\"),\n\n    plotColData(\n        sce.416b, x = \"block\", y = \"subsets_Mito_percent\",\n        colour_by = \"discard\", other_fields = \"phenotype\"\n    ) +\n        facet_wrap(~phenotype) +\n        ggtitle(\"Mito percent\"),\n\n    plotColData(\n        sce.416b, x = \"block\", y = \"altexps_ERCC_percent\",\n        colour_by = \"discard\", other_fields = \"phenotype\"\n    ) +\n        facet_wrap(~phenotype) +\n        ggtitle(\"ERCC percent\"),\n    ncol = 1\n)\n```\n:::\n\nAnother useful diagnostic involves plotting the proportion of mitochondrial counts against some of the other QC metrics. \n\nThe aim is to confirm that there are no cells with both large total counts and large mitochondrial counts, to ensure that we are not inadvertently removing **high-quality cells that happen to be highly metabolically active** (e.g., hepatocytes). \n\n\n::: {.cell}\n\n```{.r .cell-code}\n#--- loading ---#\nsce.zeisel <- ZeiselBrainData()\nsce.zeisel\n\nsce.zeisel <- aggregateAcrossFeatures(\n    sce.zeisel,\n    id = sub(\"_loc[0-9]+$\", \"\", rownames(sce.zeisel))\n)\n\n#--- gene-annotation ---#\nrowData(sce.zeisel)$Ensembl <- mapIds(\n    org.Mm.eg.db,\n    keys = rownames(sce.zeisel),\n    keytype = \"SYMBOL\",\n    column = \"ENSEMBL\"\n)\n\nsce.zeisel <- addPerCellQC(\n    sce.zeisel,\n    subsets = list(Mt = rowData(sce.zeisel)$featureType == \"mito\")\n)\n\nqc <- quickPerCellQC(\n    colData(sce.zeisel),\n    sub.fields = c(\"altexps_ERCC_percent\", \"subsets_Mt_percent\")\n)\n\nsce.zeisel$discard <- qc$discard\n\nplotColData(\n    sce.zeisel, x = \"sum\", y = \"subsets_Mt_percent\", colour_by = \"discard\"\n)\n```\n:::\n\n\nLow-quality cells with small mitochondrial percentages, large spike-in percentages and small library sizes are likely to be stripped nuclei, i.e., they have been so extensively damaged that they have lost all cytoplasmic content. \n\nOn the other hand, cells with high mitochondrial percentages and low ERCC percentages may represent undamaged cells that are metabolically active. \n\nThis interpretation also applies for single-nuclei studies but with a switch of focus: the stripped nuclei become the libraries of interest while the undamaged cells are considered to be low quality.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplotColData(\n    sce.zeisel, x=\"altexps_ERCC_percent\", y=\"subsets_Mt_percent\",\n    colour_by=\"discard\"\n)\n```\n:::\n\nThese metrics exhibit weak correlations to each other, presumably a manifestation of a common underlying effect of cell damage.\n\nThe weakness of the correlations motivates the use of several metrics to capture different aspects of technical quality.\n\nOf course, the flipside is that these metrics may also represent different aspects of biology, increasing the risk of inadvertently discarding entire cell types.\n\n### Remove low quality cells\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Keeping the columns we DON'T want to discard.\nfiltered <- sce.416b[, !reasons$discard]\n\n# Mark the low-quality cells as such and retain them in the downstream analysis\nmarked <- sce.416b\nmarked$discard <- reasons$discard\n```\n:::\n\n\n## Normalization\n\n### Library size normalization\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlib.sf.zeisel <- scater::librarySizeFactors(sce.zeisel)\nsummary(lib.sf.zeisel)\nhist(log10(lib.sf.zeisel), xlab = \"Log10[Size factor]\", col = \"grey80\")\n```\n:::\n\n\n## Session Info\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nsessionInfo()\n```\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}