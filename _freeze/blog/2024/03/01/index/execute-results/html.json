{
  "hash": "3e8ac052cc5c72e0566ec9d3a88bd555",
  "result": {
    "markdown": "---\ntitle: \"Seurat V5 | 10X course example\"\ndate: 2024-03-18\ndate-modified: last-modified\ncategories:\n  - seurat\n  - scrna\n# image:\n# description: \nexecute: \n  freeze: true\n  eval: false\n---\n\n\n\n\n## Load packages and data\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(here)\nlibrary(tidyverse)\nlibrary(Seurat)\nlibrary(SCINA)\ntheme_set(theme_bw(base_size = 14))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndir <- here(\"projects/babraham_training_bioinformatics/10X_scRNAseq_Course\")\ndata <- Read10X_h5(here(dir, \"data/filtered_feature_bc_matrix.h5\"))\ndata <- CreateSeuratObject(\n    counts = data,\n    project = \"course\",\n    min.cells = 3,\n    min.features = 200\n)\ndata\n\nhead(rownames(data))\n```\n:::\n\n\n\n## Explore QC metrics\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Amount of MT genes\ngrep(\"^MT-\", rownames(data), value = TRUE)\ndata$percent_MT <- PercentageFeatureSet(data, pattern = \"^MT-\")\nhead(data$percent_MT)\n\n### Amount of Ribosomal genes\ngrep(\"^RP[LS]\", rownames(data), value = TRUE)\ndata$percent_Ribosomal <- PercentageFeatureSet(data, pattern = \"^RP[LS]\")\nhead(data$percent_Ribosomal)\n\n### Percentage of Largest Gene\ndata_nomalat <- data[rownames(data) != \"MALAT1\", ]\n\ndata_nomalat$largest_count <- apply(\n    data_nomalat@assays$RNA@layers$counts,\n    2,\n    max\n)\n\ndata_nomalat$largest_index <- apply(\n    data_nomalat@assays$RNA@layers$counts,\n    2,\n    which.max\n)\n\ndata_nomalat$largest_gene <- rownames(data_nomalat)[data_nomalat$largest_index]\n\ndata_nomalat$percent.Largest.Gene <- 100 * data_nomalat$largest_count /\n    data_nomalat$nCount_RNA\n\ndata_nomalat[[]][1:10, ]\n\ndata$largest_gene <- data_nomalat$largest_gene\ndata$percent.Largest.Gene <- data_nomalat$percent.Largest.Gene\n\ndata[[]][1:10, ]\nrm(data_nomalat)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### For some metrics it’s better to view on a log scale.\nVlnPlot(\n    data,\n    layer = \"counts\",\n    features = c(\n        \"nCount_RNA\", \"percent_MT\", \"percent_Ribosomal\", \"percent.Largest.Gene\"\n    ),\n    ncol = 2,\n    log = TRUE\n)\n\nFeatureScatter(\n    data,\n    feature1 = \"nCount_RNA\", \n    feature2 = \"percent.Largest.Gene\"\n)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n## ggplot\nqc_metrics <- dplyr::as_tibble(\n    data[[]],\n    rownames = \"Cell.Barcode\"\n)\n\nhead(qc_metrics)\n\nqc_metrics |>\n    arrange(percent_MT) |>\n    ggplot(aes(nCount_RNA, nFeature_RNA, colour = percent_MT)) +\n    geom_point() +\n    scale_color_gradientn(colors = c(\"black\", \"blue\", \"green2\", \"red\", \"yellow\")) +\n    ggtitle(\"Example of plotting QC metrics\") +\n    geom_hline(yintercept = 750) +\n    geom_hline(yintercept = 2000)\n\n## Log scale\nqc_metrics |>\n    arrange(percent_MT) |>\n    ggplot(aes(nCount_RNA, nFeature_RNA, colour = percent_MT)) +\n    geom_point(size = 0.7) +\n    scale_color_gradientn(colors = c(\"black\", \"blue\", \"green2\", \"red\", \"yellow\")) +\n    ggtitle(\"Example of plotting QC metrics\") +\n    geom_hline(yintercept = 750) +\n    geom_hline(yintercept = 2000) +\n    scale_x_log10() +\n    scale_y_log10()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Complexity \nqc_metrics <- qc_metrics |>\n  mutate(complexity=log10(nFeature_RNA) / log10(nCount_RNA))\n\ncomplexity.lm <- lm(log10(qc_metrics$nFeature_RNA)~log10(qc_metrics$nCount_RNA)) \n\ncomplexity.lm\n\nqc_metrics <- qc_metrics |>\n  mutate(\n    complexity_diff = log10(nFeature_RNA) - ((log10(qc_metrics$nCount_RNA)*complexity.lm$coefficients[2])+complexity.lm$coefficients[1])\n  )\n\nqc_metrics |>\n  ggplot(aes(x=complexity_diff)) +\n  geom_density(fill=\"yellow\") \n\ncomplexity_scale <- min(c(max(qc_metrics$complexity_diff),0-min(qc_metrics$complexity_diff)))\n\nqc_metrics |>\n  mutate(complexity_diff=replace(complexity_diff,complexity_diff< -0.1,-0.1)) |>\n  ggplot(aes(x=log10(nCount_RNA), y=log10(nFeature_RNA), colour=complexity_diff)) +\n  geom_point(size=0.5) +\n  geom_abline(slope=complexity.lm$coefficients[2], intercept = complexity.lm$coefficients[1]) +\n  scale_colour_gradient2(low=\"blue2\",mid=\"grey\",high=\"red2\")\n\nqc_metrics |>\n  ggplot(aes(x=complexity_diff, y=percent.Largest.Gene)) +\n  geom_point()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Largest gene\nlargest_gene_list <- qc_metrics |>\n    group_by(largest_gene) |>\n    count() |>\n    arrange(desc(n))\n\nlargest_genes_to_plot <- largest_gene_list |>\n    filter(n > 140) |>\n    pull(largest_gene)\n\nqc_metrics |>\n    filter(largest_gene %in% largest_genes_to_plot) |>\n    mutate(\n      largest_gene = factor(largest_gene, levels = largest_genes_to_plot)\n    ) |>\n    arrange(largest_gene) |>\n    ggplot(\n      aes(x = log10(nCount_RNA), y = log10(nFeature_RNA), colour = largest_gene)\n    ) +\n    geom_point(size = 1) +\n    scale_colour_manual(\n      values = c(\"grey\", RColorBrewer::brewer.pal(9, \"Set1\"))\n    )\n\nqc_metrics |>\n    filter(largest_gene %in% largest_genes_to_plot) |>\n    mutate(\n      largest_gene = factor(largest_gene, levels = largest_genes_to_plot)\n    ) |>\n    arrange(largest_gene) |>\n    ggplot(\n      aes(x = complexity_diff, y = percent.Largest.Gene, colour = largest_gene)\n    ) +\n    geom_point() +\n    scale_colour_manual(values = c(\"grey\", RColorBrewer::brewer.pal(9, \"Set1\")))\n\nqc_metrics |>\n    arrange(percent_MT) |>\n    ggplot(\n      aes(x = complexity_diff, y = percent.Largest.Gene, colour = percent_MT)\n    ) +\n    geom_point() +\n    scale_colour_gradient(low = \"grey\", high = \"red2\")\n\nqc_metrics |>\n    arrange(percent_Ribosomal) |>\n    ggplot(\n      aes(x = complexity_diff, y = percent.Largest.Gene, colour = percent_Ribosomal)\n    ) +\n    geom_point() +\n    scale_colour_gradient(low = \"grey\", high = \"red2\")\n```\n:::\n\n\n## Setting QC Cutoff and Filtering\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqc_metrics |>\n    ggplot(aes(percent_MT)) +\n    geom_histogram(binwidth = 0.5, fill = \"yellow\", colour = \"black\") +\n    ggtitle(\"Distribution of Percentage Mitochondrion\") +\n    geom_vline(xintercept = 10)\n\nqc_metrics |>\n    ggplot(aes(percent.Largest.Gene)) +\n    geom_histogram(binwidth = 0.7, fill = \"yellow\", colour = \"black\") +\n    ggtitle(\"Distribution of Percentage Largest Gene\") +\n    geom_vline(xintercept = 10) ### Filtering\n\ndata <- subset(\n    data,\n    nFeature_RNA > 750 &\n        nFeature_RNA < 2000 &\n        percent_MT < 10 &\n        percent.Largest.Gene < 10\n)\n\ndata\n```\n:::\n\n\n## Normalisation, Selection and Scaling\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Normalization\ndata <- NormalizeData(data, normalization.method = \"LogNormalize\")\n\ngene_expression <- apply(data@assays$RNA@layers$data, 1, mean)\ngene_expression <- names(gene_expression) <- rownames(data)\ngene_expression <- sort(gene_expression, decreasing = TRUE)\nhead(gene_expression, n = 10)\n\nggplot(mapping = aes(data[\"GAPDH\", ]@assays$RNA@layers$data)) +\n    geom_histogram(binwidth = 0.05, fill = \"yellow\", colour = \"black\") +\n    ggtitle(\"GAPDH expression\")\n\n\nas_tibble(\n    data@assays$RNA@layers$data[, 1:100]\n) |>\n    pivot_longer(\n        cols = everything(),\n        names_to = \"cell\",\n        values_to = \"expression\"\n    ) |>\n    ggplot(aes(x = cell, y = expression)) +\n    stat_summary(geom = \"crossbar\", fun.data = mean_sdl)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Cell Cycle Scoring\ncc.genes.updated.2019\n\ndata <- CellCycleScoring(\n    data,\n    s.features = cc.genes.updated.2019$s.genes,\n    g2m.features = cc.genes.updated.2019$g2m.genes,\n    set.ident = TRUE\n)\n\nas_tibble(data[[]])\n\nas_tibble(data[[]]) |>\n    ggplot(aes(Phase)) + geom_bar()\n\nas_tibble(data[[]]) |>\n    ggplot(aes(x = S.Score, y = G2M.Score, color = Phase)) +\n    geom_point() +\n    coord_cartesian(xlim = c(-0.15, 0.15), ylim = c(-0.15, 0.15))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Gene selection\ndata <- FindVariableFeatures(\n    data,\n    selection.method = \"vst\",\n    nfeatures = 500\n)\n\nvariance_data <- as_tibble(\n    HVFInfo(data), rownames = \"Gene\"\n)\n\nvariance_data <- variance_data |>\n    mutate(\n        hypervariable = Gene %in% VariableFeatures(data)\n    )\n\nhead(variance_data, n = 10)\n\nvariance_data |>\n    ggplot(aes(log(mean), log(variance), color = hypervariable)) +\n    geom_point() +\n    scale_color_manual(values = c(\"black\", \"red\"))\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Scaling\ndata <- ScaleData(data, features = rownames(data))\n```\n:::\n\n\n## Dimensionality reduction\n\n### PCA\n\n::: {.cell}\n\n```{.r .cell-code}\n### Calculate all PCs\n### list of genes which are most highly and lowly weighted in the different PCs\ndata <- RunPCA(data, features = VariableFeatures(data))\n\n### See if the cell cycle is having a big effect on the clusters we’re picking out\nDimPlot(data, reduction = \"pca\")\n\nDimPlot(\n    data, reduction = \"pca\",\n    group.by = \"largest_gene\",\n    label = TRUE,\n    label.size = 3\n) + NoLegend()\n\n### This nicely shows us the power, but also the limitations of PCA in that we \n### can see that not all of the useful information is captured in the first two \n### principal components.\nDimPlot(data, reduction = \"pca\", dims = c(3, 4))\n\n### How far down the set of PCs do we need to go to capture all of the \n### biologically relevant information.\nElbowPlot(data)\n\n### Plots of PCA weightings for the most highly and lowly weighted genes, \n### shown against the set of cells which are most highly influenced by the PC. \n### The idea is that as long as we’re seeing clear structure in one of these \n### plots then we’re still adding potentially useful information to the analysis.\nDimHeatmap(data, dims = 1:15, cells = 500)\n```\n:::\n\n\n### tSNE\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Setting this to a low value will help resolve small clusters, \n### but at the expense of large clusters becoming more diffuse\nsaved_seed <- 8482\nset.seed(saved_seed)\n\ndata <- RunTSNE(data, dims = 1:15, seed.use = saved_seed, perplexity = 10)\nDimPlot(data, reduction = \"tsne\", pt.size = 1) +\n    ggtitle(\"tSNE with Perplexity 10\")\n\ndata <- RunTSNE(data, dims = 1:15, seed.use = saved_seed, perplexity = 200)\nDimPlot(data, reduction = \"tsne\", pt.size = 1) +\n    ggtitle(\"tSNE with Perplexity 200\")\n\ndata <- RunTSNE(data, dims = 1:15, seed.use = saved_seed)\nDimPlot(data, reduction = \"tsne\", pt.size = 1) +\n    ggtitle(\"tSNE with default Perplexity (30)\")\n```\n:::\n\n\n\n## Defining Cell Clusters\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Finds the ‘k’ nearest neighbours to each cell and makes this into a graph\ndata <- FindNeighbors(data, dims = 1:15)\n\n### Get another sparse matrix of distances.\ndata@graphs$RNA_snn[1:10, 1:10]\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Segment the graph, \n### Larger resolution give larger clusters, smaller values gives smaller clusters.\ndata <- FindClusters(data, resolution = 0.5)\n\nhead(data$seurat_clusters, n = 5)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Some of the clusters don't resolve very well in PC1 vs PC2\nDimPlot(data, reduction = \"pca\", label = TRUE) +\n    ggtitle(\"PC1 vs PC2 with Clusters\")\n\n### Some of the clusters which are overlaid in PC1 start to separate in other PCs\n### These differences represent a small proportion of the overall variance\n### but can be important in resolving changes.\nDimPlot(data, reduction = \"pca\", dims = c(4, 9), label = TRUE) +\n    ggtitle(\"PC4 vs PC9 with Clusters\")\n\n### tSNE plot showing all of the information across the PCs used is preserved\n### and we see the overall similarity of the cells\nDimPlot(data, reduction = \"tsne\", pt.size = 1, label = TRUE, label.size = 7)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Check the clusters to see if they are influenced by any of the QC metrics\n### We can see that some of the clusters are skewed in one or more of the\n### metrics we’ve calculated so we will want to take note of this.\n### Some of these skews could be biological in nature,\n### but they could be noise coming from the data.\nVlnPlot(data, features = \"nCount_RNA\")\n\n### Cluster 8, 9, 11, and 12 could be GEMs where two or more cells were captured\n### Since they all usually high coverage and diversity\n### Theya are also small and tightly clustered away from the main groups of points\nVlnPlot(data, features = \"nFeature_RNA\")\n\nVlnPlot(data, features = \"percent_MT\")\n\nVlnPlot(data, features = \"MALAT1\")\n\nVlnPlot(data,features=\"percent.Largest.Gene\")\n\n### Which largest gene\ndata[[]] |>\n    group_by(seurat_clusters, largest_gene) |>\n    count() |>\n    arrange(desc(n)) |>\n    group_by(seurat_clusters) |>\n    slice(1:2) |>\n    ungroup() |>\n    arrange(seurat_clusters, desc(n))\n\n### Cell cycle\ndata@meta.data |>\n    group_by(seurat_clusters, Phase) |>\n    count() |>\n    group_by(seurat_clusters) |>\n    mutate(percent = 100 * n / sum(n)) |>\n    ungroup() |>\n    ggplot(aes(x = seurat_clusters, y = percent, fill = Phase)) +\n    geom_col() +\n    ggtitle(\"Percentage of cell cycle phases per cluster\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### That’s already quite nice for explaining some of the functionality of the \n### clusters, but there’s more in there than just the behaviour of the most \n### expressed gene\ndata@reductions$tsne@cell.embeddings |>\n    as_tibble() |>\n    add_column(\n      seurat_clusters = data$seurat_clusters, largest_gene = data$largest_gene\n    ) |>\n    filter(largest_gene %in% largest_genes_to_plot) |>\n    ggplot(aes(x = tSNE_1, y = tSNE_2, colour = seurat_clusters)) +\n    geom_point() +\n    facet_wrap(vars(largest_gene))\n```\n:::\n\n\n## Find Markers\n\n\n::: {.cell}\n\n```{.r .cell-code}\n### Evaluate the cluster by identifying genes whose expression definies each\n### cluster which has been identified\n\n### Find genes appears to be upregulated in a specific cluster compared to all\n### cells not in that cluster\nFindMarkers(data, ident.1 = 0, min.pct = 0.25)[1:5, ]\n\n### Show the expression levels of these genes in the cells in each cluster\n### VCAN gene is more highly expressed in cluster 0 than any of the other \n### clusters, but we can also see that it is also reasonably highly expressed \n### in clusters 9 and 12. These were both clusters we suspected of being \n### multiple cells though\nVlnPlot(data, features = \"VCAN\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### FindMarkers function on all of the clusters\ncluster_markers <- lapply(\n    levels(data[[\"seurat_clusters\"]][[1]]),\n    function(x) FindMarkers(data, ident.1 = x, min.pct = 0.25)\n)\n\n### Adds the cluster number to the results of FindMarkers\nsapply(\n    0:(length(cluster_markers) - 1),\n    function(x) {\n        cluster_markers[[x + 1]]$gene <<- rownames(cluster_markers[[x + 1]])\n        cluster_markers[[x + 1]]$cluster <<- x\n    }\n)\n\n### Generate tibble and sort by FDR to put the most significant ones first\ncluster_markers <- as_tibble(do.call(rbind, cluster_markers)) |>\n    arrange(p_val_adj)\n\ncluster_markers\n\n### Extract the most upregulated gene from each cluster\nbest_wilcox_gene_per_cluster <- cluster_markers |>\n    group_by(cluster) |>\n    slice(1) |>\n    pull(gene)\n\n### We can see that for some clusters (eg Cluster 8 - CDKN1C) We really do have\n### a gene which can uniquely predict, but for many others (eg cluster 7 IL7R)\n### we have a hit which also picks up other clusters (clusters 1, 3 and 4 in this case).\nVlnPlot(data, features = best_wilcox_gene_per_cluster)\n\n### Clean this up for any individual cluster by using the roc analysis.\nFindMarkers(\n    data, ident.1 = 7, ident.2 = 4, test.use = \"roc\", only.pos = TRUE\n)[1:5, ]\n\n### Slightly better job at separating cluster 5 from cluster 4, but it also\n### comes up all over the place in other clusters\nVlnPlot(data, features = \"LTB\")\n\n### This could actually be a better option to use as a marker for this cluster.\nVlnPlot(data, features = \"TPT1\")\n```\n:::\n\n\n## Automated Cell Type Annotation\n\n::: {.cell}\n\n```{.r .cell-code}\nscina_data <- as.data.frame(GetAssayData(data, layer = \"data\"))\n\nsignatures <- get(\n    load(system.file(\"extdata\", \"example_signatures.RData\", package = \"SCINA\"))\n)\n\nsignatures\n\nscina_results <- SCINA(\n    scina_data,\n    signatures,\n    max_iter = 100,\n    convergence_n = 10,\n    convergence_rate = 0.999,\n    sensitivity_cutoff = 0.9,\n    rm_overlap = TRUE,\n    allow_unknown = TRUE\n)\n\ndata$scina_labels <- scina_results$cell_labels\n\n### plot out the tsne spread coloured by the automatic annotation\nDimPlot(\n    data, reduction = \"tsne\", pt.size = 1, label = TRUE,\n    group.by = \"scina_labels\", label.size = 5\n)\n\n### Relate this to the clusters which we automatically detected.\ntibble(\n    cluster = data$seurat_clusters,\n    cell_type = data$scina_labels\n) |>\n    group_by(cluster, cell_type) |>\n    count() |>\n    group_by(cluster) |>\n    mutate(\n        percent = (100 * n) / sum(n)\n    ) |>\n    ungroup() |>\n    mutate(\n        cluster = paste(\"Cluster\", cluster)\n    ) |>\n    ggplot(aes(x = \"\", y = percent, fill = cell_type)) +\n    geom_col(width = 1) +\n    coord_polar(\"y\", start = 0) +\n    facet_wrap(vars(cluster)) +\n    theme(axis.text.x = element_blank()) +\n    xlab(NULL) +\n    ylab(NULL)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n### Colouring by genes\n### Some of these genes very specifically isolate to their own cluster, but for\n### others we see expression which is more widely spread over a number of clusters\nFeaturePlot(data, features = best_wilcox_gene_per_cluster, ncol = 3)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ndata@reductions$tsne@cell.embeddings[1:10, ]\n\n# data@reductions$tsne@cell.embeddings[, ] |>\n#     as_tibble(rownames = \"barcode\") |>\n#     mutate(barcode = paste0(barcode, \"-1\")) |>\n#     write_csv(\"for_loupe_import.csv\")\n```\n:::\n\n\n## Reference\n\n1. [Seurat Example](https://www.bioinformatics.babraham.ac.uk/training/10XRNASeq/seurat_workflow.html#Gene_Selection)\n\n2. [Single-cell RNA-seq data analysis workshop](https://hbctraining.github.io/scRNA-seq_online/schedule/links-to-lessons.html)\n\n\n\n## Session info\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nsessionInfo()\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}